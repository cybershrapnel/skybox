<!DOCTYPE html>
<html lang="en">
<head>
  <title>Digital Skybox</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <link rel="stylesheet" type="text/css" href="resources/css/jquery-ui.css">
  <link rel="stylesheet" type="text/css" href="css/uncharted.css">

  <script type="text/javascript" src="resources/jquery-2.0.0.min.js"></script>
  <script type="text/javascript" src="resources/tinycolor-min.js"></script>
  <script type="text/javascript" src="resources/jquery-ui.min.js"></script>
  <script src="resources/three.min.js"></script>
  <script src="resources/stats.js"></script>
  <script src="js/constants.js"></script>
  <script src="js/FreeLookControls.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/DynamicMarker.js"></script>
  <script src="js/TweenControls.js"></script>
  <script src="js/TooltipMarker.js"></script>
  <script src="js/System.js"></script>
  <script src="js/Shaders.js"></script>
  <script src="js/CircularQueue.js"></script>
  <script src="js/RollingAverage.js"></script>
  <script src="js/PlanetBuilder.js"></script>
  <script src="resources/Detector.js"></script>

  <!-- Catalog UI styles -->
  <style>
    #catalogStatus {
      font-size: 11px;
      line-height: 1.3;
      margin-top: 6px;
      color: #cfcfcf;
      word-break: break-word;
    }
    .catalog-btn {
      margin: 4px 0;
      width: 100%;
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    #starmapListContainer {
      margin-top: 8px;
      max-height: 180px;
      overflow-y: auto;
      border: 1px solid #444;
      background: rgba(0,0,0,0.35);
      padding: 6px;
      font-size: 12px;
    }
    .starmap-item {
      padding: 6px 8px;
      margin: 2px 0;
      cursor: pointer;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .starmap-item:hover {
      background: rgba(255,255,255,0.12);
    }
    .starmap-name {
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .starmap-size {
      color:#9aa;
      font-size:11px;
      white-space:nowrap;
    }
  </style>
</head>

<body>

<div>
  <div id="selector">
    <h3><span id="info-header" class="accordion-header"></span><b> - <span id="distance-header"
                                                                           class="accordion-header"></span></b></h3>
    <div class="overlay-panel">
      <table>
        <tbody id="info-table"></tbody>
      </table>
    </div>

    <h3>Explore Local Skybox</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <label for="jump_to_list">Search: </label>
        <input id="jump_to_list" type="text">
      </div>
    </div>

    <h3>MEQUAVIS Location Data</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <font size=2>Current Phase Layer Location:</font> <br />1@2.1.1.1.1.1:0<br /><br />
        <input id="jump_to_list" type="text">
        <br />
        <font size=1><center> Obtain a valid MEQUAVIS hyperstack<br />
                             address from the NanoCheeZe JAVA app<br />
                             hint: There is only 1 active layer atm</center></font>
      </div>
    </div>

    <h3>Load and View in VR</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <a href="https://xtdevelopment.net/babylon">Launch in VR</a><br />
      </div>
    </div>

    <!-- Catalog panel -->
    <h3>Catalog</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <button id="loadCatalogBtn" class="catalog-btn">Load Local star_catalog.txt</button>
        <button id="clearCatalogBtn" class="catalog-btn">Reload Default Server Catalog</button>
        <input id="catalogFileInput" type="file" accept=".txt,.json,application/json,text/plain" style="display:none;">
        <div id="catalogStatus">Using server catalog.</div>

        <div id="starmapListContainer">
          <div style="font-size:11px;color:#bbb;margin-bottom:6px;">Available starmaps:</div>
          <div id="starmapList">
            <div style="color:#888;">List will load after map starts…</div>
          </div>
        </div>
      </div>
    </div>

    <h3>View</h3>
    <div class="overlay-panel">
      <table>
        <tbody>

        <tr class="header-row overlay-header">
          <td><b>Control Mode</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="control_mode" name="control_mode" action="#" method="POST">
              <div>
                <label><input type="radio" name="control_mode" value="orbit" checked></label> Orbit
                <label><input type="radio" name="control_mode" value="free"></label> Free Look
              </div>
            </form>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Virtual Stars</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <input type="checkbox" id="virtual_stars_checkbox" name="virtual_stars"> Enable Virtual Stars
            <div>
              <button id="autoExploreButton">Toggle Auto Explore</button>
            </div>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Render Radius (Sol lys)</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="render_radius" name="render_radius" action="#" method="POST">
              <div>
                <label><input type="radio" name="render_radius" value="10"></label> 10
                <label><input type="radio" name="render_radius" value="25"></label> 25
                <label><input type="radio" name="render_radius" value="50"></label> 50
              </div>
              <div>
                <label><input type="radio" name="render_radius" value="75" checked></label> 75
                <label><input type="radio" name="render_radius" value="150"></label> 150
                <label><input type="radio" name="render_radius" value="200"></label> 200
              </div>
            </form>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Highlight</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="highlight_mode" name="highlight_mode" action="#" method="POST">
              <div>
                <label><input type="radio" name="highlight_mode" value="none" checked></label> None
                <label><input type="radio" name="highlight_mode" value="exoplanets"></label> Exoplanets
                <label><input type="radio" name="highlight_mode" value="all"></label> All
              </div>
            </form>
          </td>
        </tr>

        <!-- Menu collapse -->
        <tr class="header-row overlay-header">
          <td><b>Menu</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <button id="collapseMenuBtn" class="catalog-btn">Collapse menu</button>
          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>

<div id="attribution-overlay">
  <span id="page-counter"></span><br />
  <a href="https://mequavis.com" target="_self">MEQUAVIS.COM</a><br />
</div>


  <canvas id='webgl_canvas'></canvas>
</div>

<script>
  // visits counter
  const pageURL = encodeURIComponent(window.location.href);
  const counterURL = `https://www.xtdevelopment.net/hits/index.php?page=${pageURL}`;

  // DEFAULT CATALOG (LOCAL to skybox.nanocheeze.com)
  const DEFAULT_CATALOG_URL = "star_catalog.txt";  // relative = same server as skybox.html

  fetch(counterURL)
    .then(r => r.json())
    .then(data => {
      document.getElementById('page-counter').textContent =
        data.hits ? `Visits: ${data.hits}` : 'Visit count unavailable';
    })
    .catch(() => {
      document.getElementById('page-counter').textContent = 'Visit count unavailable';
    });

  // virtual stars
  let virtualStars = [];

  function createVirtualStars() {
    const numStars = (100*renderRadius)-900;
    const maxDistance = renderRadius * 12;

    for (let i = 0; i < numStars; i++) {
      const randomX = Math.random() * maxDistance - maxDistance / 2;
      const randomY = Math.random() * maxDistance - maxDistance / 2;
      const randomZ = Math.random() * maxDistance - maxDistance / 2;

      const clickableGeometry = new THREE.SphereGeometry(0.3, 8, 8);
      const starMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 0.8,
        transparent: true
      });
      const virtualStar = new THREE.Mesh(clickableGeometry, starMaterial);
      virtualStar.position.set(randomX, randomY, randomZ);

      const planetGeometry = new THREE.SphereGeometry(0.05, 8, 8);

      const getRandomColor = () => {
        const colorType = Math.random();
        if (colorType < 0.3) {
          if (Math.random() < 0.5) {
            return new THREE.Color(Math.random() * 0.5, Math.random() * 0.5 + 0.5, 1);
          } else {
            return new THREE.Color(1, Math.random() * 0.5, Math.random() * 0.5 + 0.5);
          }
        } else {
          const solidColors = [
            new THREE.Color(1, 0, 0),
            new THREE.Color(0, 1, 0),
            new THREE.Color(0, 0, 1),
            new THREE.Color(1, 0, 1)
          ];
          return solidColors[Math.floor(Math.random() * solidColors.length)];
        }
      };

      const planetMaterial = new THREE.MeshBasicMaterial({ color: getRandomColor() });
      const innerPlanet = new THREE.Mesh(planetGeometry, planetMaterial);
      innerPlanet.position.set(0, 0, 0);
      virtualStar.add(innerPlanet);

      const moonGeometry = new THREE.SphereGeometry(0.005, 8, 8);
      const moonMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
      const moon = new THREE.Mesh(moonGeometry, moonMaterial);
      moon.position.set(0, 0, 0);
      moon.objectData = { type: "MOON" };
      innerPlanet.add(moon);

      virtualStar.objectData = {
        primaryId: `virtual_star_${i}`,
        properName: `Virtual Star ${i + 1}`,
        type: "VIRTUAL_STAR",
        radius: { value: { quantity: 0.01 } },
        solDistance: { value: { quantity: Math.random() * renderRadius } },
        nearbyObjectIDs: [],
        cartesianCoordsInLys: { x: randomX, y: randomY, z: randomZ }
      };

      scene.add(virtualStar);
      stars.push(virtualStar);
      virtualStars.push(virtualStar);
    }
  }

  function removeVirtualStars() {
    virtualStars.forEach(star => {
      scene.remove(star);
      const indexInStars = stars.indexOf(star);
      if (indexInStars !== -1) stars.splice(indexInStars, 1);
    });
    virtualStars = [];
  }

  document.getElementById('virtual_stars_checkbox').addEventListener('change', function() {
    if (this.checked) createVirtualStars();
    else removeVirtualStars();
  });
</script>

<script>
  // accordion + collapse
  $(function () {
    $("#selector").accordion({
      collapsible: true,
      animate: 100,
      heightStyle: 'panel',
      active: 4
    });

    let menuCollapsed = false;

    function collapseMenu() {
      const $acc = $("#selector");
      const $headers = $acc.children("h3");
      const $panels = $headers.next();

      $acc.accordion("option", "active", false);
      $headers.not(":first").hide();
      $panels.not(":first").hide();

      menuCollapsed = true;
    }

    function restoreMenu() {
      const $acc = $("#selector");
      const $headers = $acc.children("h3");
      const $panels = $headers.next();

      $headers.show();
      $panels.show();

      menuCollapsed = false;
      $acc.accordion("refresh");
    }

    $("#collapseMenuBtn").on("click", function(e){
      e.preventDefault();
      if (!menuCollapsed) collapseMenu();
    });

    $("#selector").children("h3").first().on("click", function(){
      if (menuCollapsed) restoreMenu();
    });
  });

  var distanceHeader = $("#distance-header");
  var lastDistance;

  if (!Detector.webgl) Detector.addGetWebGLMessage();

  var SURROUND_GEOMETRY = new THREE.SphereGeometry(1.0, 8, 8);
  var ZERO = new THREE.Vector3(0, 0, 0);

  var canvas = $("#webgl_canvas").get(0);
  var scene = new THREE.Scene();

  var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.0000000005, 10000);
  camera.position.set(0, 0, -35);
  camera.rotateZ(Math.PI);
  camera.rotateY(Math.PI);

  var intersectCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .01, 10000);

  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  var clock = new THREE.Clock();

  var solMarker = new DynamicMarker(new THREE.Vector3(0, 0, 0), SOL_MARKER_RADIUS, 0x0000FF, 0);

  var selector = new DynamicMarker(new THREE.Vector3(0, 0, 0), MARKER_RADIUS, 0x00b33c, Math.PI / 4);

  var lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, depthWrite: false });

  var uniforms = { time: {type: "f", value: 1.0}, scale: {type: "f", value: 80} };

  var lineSegment;
  var tooltip;
  var tooltipObject;
  var font;

  var mouseX;
  var mouseY;
  var mouseMoved = false;

  var controlMode = '';
  var highlightMode = 'none';

  var renderer = new THREE.WebGLRenderer({ canvas: canvas, logarithmicDepthBuffer: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = true;

  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();

  var freeLookControls = new THREE.FreeLookControls(camera, canvas);
  var orbitControls = new THREE.OrbitControls(camera, canvas);
  var tweenControls = new THREE.TweenControls(camera);

  var shaders = new Shaders();

  var light = new THREE.AmbientLight(0x404040);
  scene.add(light);

  scene.add(camera);
  scene.add(intersectCamera);
  scene.add(solMarker.mesh);
  scene.add(selector.mesh);

  var starData;
  var planetData;

  var stars = [];
  var starsByID = {};
  var planetsByStarID = {};
  var visibleStars = [];
  var visibleStarsByName = {};
  var renderRadius = 75;

  $("#jump_to_list").keydown(function (e) {
    if (e.keyCode == 13) {
      e.preventDefault();
      select(visibleStarsByName[this.value]);
    }
  });

  $("#render_radius").click(function () {
    renderRadius = $('input[name=render_radius]:checked', '#render_radius').val();
    updateobjectData();
  });

  $('#control_mode').click(function () {
    controlMode = $('input[name=control_mode]:checked', '#control_mode').val();
    updateTarget();
  });

  $("#highlight_mode").click(function () {
    highlightMode = $('input[name=highlight_mode]:checked', '#highlight_mode').val();
    stars.forEach(function (starMesh) { updateHighlight(starMesh); });
  });

  var HIGHLIGHT_MAP = new THREE.TextureLoader().load("images/highlight.png");
  var SPRITE_MATERIAL = new THREE.SpriteMaterial({ map: HIGHLIGHT_MAP, depthWrite: false });

  function updateTarget(prevStarMesh) {
    var prevControlMode = controlMode;
    controlMode = 'tween';

    var finalZoom = function (approachTime) {
      return function () {
        tweenControls.setZoom(
          absolutePosition(currentObjectMesh),
          currentObjectMesh.objectData.radius.value.quantity * 10,
          approachTime,
          function () {
            if (isStar(currentObjectMesh)) currentSystem.populatePlanets();
            if (isStar(prevStarMesh)) {
              (prevStarMesh.objectData.nearbyObjectIDs || []).forEach(function (e) {
                resetStarScale(starsByID[e]);
              });
            }
            controlMode = (!prevControlMode || prevControlMode == 'tween') ? 'orbit' : prevControlMode;

            orbitControls.orbit(
              absolutePosition(currentObjectMesh),
              currentObjectMesh.objectData.radius.value.quantity * 2
            );
          }
        );
      };
    };

    if (isStar(currentObjectMesh)) {
      tweenControls.setZoom(absolutePosition(currentObjectMesh), MARKER_RADIUS, 2, finalZoom(1));
    } else {
      finalZoom(2)();
    }
  }

  function isStar(mesh) { return mesh && mesh.objectData.type == "STAR"; }

  var currentObjectPrimaryId = "";
  var currentObjectMesh;
  var currentSystem;

  function reassignLabel(targetMesh) {
    if (!tooltipObject || tooltipObject.objectData.primaryId == targetMesh.objectData.primaryId) return;
    doReassign(targetMesh);
  }

  var labelCache = {};

  function absolutePosition(mesh) {
    scene.updateMatrixWorld();
    var vector = new THREE.Vector3();
    vector.setFromMatrixPosition(mesh.matrixWorld);
    return vector;
  }

  function doReassign(targetMesh) {
    tooltipObject = targetMesh;

    scene.remove(lineSegment);
    if (tooltip) scene.remove(tooltip.object);

    var targetPos = absolutePosition(targetMesh);
    var geometry = new THREE.Geometry();
    var currentObjPosition = absolutePosition(currentObjectMesh);

    geometry.vertices.push(currentObjPosition);
    geometry.vertices.push(targetPos);
    lineSegment = new THREE.Line(geometry, lineMaterial);

    var lineDistance = currentObjectMesh ? currentObjectMesh.position.distanceTo(targetPos) : 0;
    var label = targetMesh.objectData.properName || "Unnamed Star";
    var cacheKey = label + lineDistance;

    var radiusQuantity = (targetMesh.objectData.radius && targetMesh.objectData.radius.value && targetMesh.objectData.radius.value.quantity) || 0.01;

    if (!labelCache[cacheKey]) {
      labelCache[cacheKey] = new TooltipMarker(label, prettyDistance(lineDistance), radiusQuantity);
    }

    tooltip = labelCache[cacheKey];
    tooltip.object.position.set(targetPos.x, targetPos.y, targetPos.z);

    scene.add(lineSegment);
    scene.add(tooltip.object);

    tooltip.updateTo(camera);
  }

  function isRender(objectData) {
    return objectData.solDistance.value.quantity < renderRadius;
  }

  function updateHighlight(starMesh) {
    const highlight = starMesh.children[0];

    if (highlightMode === 'none' ||
        (currentSystem && starMesh.objectData.primaryId === currentSystem.star.objectData.primaryId)) {
      if (highlight) starMesh.remove(highlight);
    } else if (highlightMode === 'exoplanets' && starMesh.objectData.type === "STAR") {
      if (planetsByStarID[starMesh.objectData.primaryId] &&
          planetsByStarID[starMesh.objectData.primaryId][0]) {
        if (!highlight) starMesh.add(createHighlightSprite());
      } else {
        starMesh.remove(highlight);
      }
    } else if (highlightMode === 'all' || starMesh.objectData.type === "VIRTUAL_STAR") {
      if (!highlight) starMesh.add(createHighlightSprite());
    }
  }

  function updateobjectData() {
    var renderedStars = {};
    visibleStars.forEach(function (e) { renderedStars[e.objectData.primaryId] = true; });

    visibleStars = [];
    visibleStarsByName = {};
    var nameList = [];

    stars.forEach(function (starMesh) {
      var data = starMesh.objectData;
      var starID = data.primaryId;
      var commonName = data.properName || ("Star " + starID);

      nameList.push(commonName);
      visibleStarsByName[commonName] = starMesh;

      if (isRender(data)) {
        visibleStars.push(starMesh);
        if (!renderedStars[starID]) scene.add(starMesh);
      } else {
        if (renderedStars[starID]) {
          scene.remove(starMesh);
          renderedStars[starID] = null;
        }
      }
    });

    if (currentSystem == null) {
      const defaultStar = starsByID[1] || stars[0];
      if (defaultStar) {
        select(defaultStar);
        const labelStar = starsByID[70667] || stars[1] || defaultStar;
        if (labelStar) reassignLabel(labelStar);
      }
    } else if (currentSystem && !renderedStars[currentSystem.star.primaryId]) {
      const fallback = starsByID[1] || stars[0];
      if (fallback) select(fallback);
    }

    $("#jump_to_list").autocomplete({ source: nameList, minLength: 4 });
  }

  function closestNonPrimaryObject(intersects, currentPrimary, currentStarPrimary) {
    if (intersects.length == 0) return null;

    var firstIntersect = intersects[0].object;
    var firstIntersectId = firstIntersect.objectData.primaryId;

    if (intersects.length == 1 && currentPrimary) {
      if (firstIntersectId == currentStarPrimary) return firstIntersect;
      if (firstIntersectId != currentPrimary) return firstIntersect;
    }

    var lookPoint = camera.position;
    var min = Number.MAX_VALUE;
    var best = null;

    intersects.forEach(function (e) {
      var screenDistance = e.object.position.distanceTo(e.point) / lookPoint.distanceTo(e.point);
      var intersectId = e.object.objectData.primaryId;

      if (screenDistance < min && intersectId != currentPrimary && intersectId != currentStarPrimary) {
        best = e.object;
        min = screenDistance;
      }
    });

    return best;
  }

  function getStarForPoint(x, y) {
    if (x && y) {
      mouse.x = (x / window.innerWidth) * 2 - 1;
      mouse.y = -(y / window.innerHeight) * 2 + 1;

      intersectCamera.position.copy(camera.position);
      intersectCamera.rotation.copy(camera.rotation);
      raycaster.setFromCamera(mouse, intersectCamera);

      if (currentSystem) {
        var last = closestNonPrimaryObject(
          raycaster.intersectObjects(currentSystem.selectable, false),
          currentObjectPrimaryId,
          currentSystem.star.objectData.primaryId
        );
        if (last) return currentSystem.objectsByID[last.objectData.primaryId];
      }

      var allStars = visibleStars.concat(virtualStars);
      var lastStar = closestNonPrimaryObject(
        raycaster.intersectObjects(allStars, false),
        currentObjectPrimaryId,
        null
      );

      if (lastStar) return lastStar;

      if (tooltip) {
        var text = raycaster.intersectObjects(tooltip.scaleObj.children, false);
        if (text.length > 0) return tooltipObject;
      }
    }
    return null;
  }

  function setMouseXY(event) {
    mouseX = event.clientX;
    mouseY = event.clientY;
    mouseMoved = true;
  }

  function consumeMouseMove() {
    if (!mouseMoved) return false;
    mouseMoved = false;
    return true;
  }

  function getMouseoverStar() {
    if (!freeLookControls.dragView && consumeMouseMove()) {
      var object = getStarForPoint(mouseX, mouseY);
      canvas.style.cursor = object ? 'pointer' : 'auto';
      if (object) reassignLabel(object);
    }
  }

  function onMouseClick(event) {
    const diffX = Math.abs(mouseDownX - event.clientX);
    const diffY = Math.abs(mouseDownY - event.clientY);
    const delta = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
    if (delta < 5) {
      const clickedStar = getStarForPoint(event.clientX, event.clientY);
      if (clickedStar) select(clickedStar);
    }
  }

  function initializeobjectData() {
    starData.forEach(function (star) {
      var tempQ = (star.temperatureEstimate && star.temperatureEstimate.value && star.temperatureEstimate.value.quantity) || 5000;

      var shaderSurround = new THREE.ShaderMaterial({
        vertexShader: shaders.coronaVertexShader,
        fragmentShader: shaders.coronaFragmentShader,
        uniforms: {
          scale: {type: "f", value: 0.0},
          temp: {type: "f", value: tempQ / 2}
        },
        transparent: true,
        depthWrite: false,
        polygonOffset: .1,
        usePolygonOffset: true
      });

      var surround = new THREE.Mesh(SURROUND_GEOMETRY, shaderSurround);
      surround.objectData = star;
      resetStarScale(surround);
      updateHighlight(surround);

      surround.position.x = star.cartesianCoordsInLys.x;
      surround.position.y = star.cartesianCoordsInLys.y;
      surround.position.z = star.cartesianCoordsInLys.z;

      starsByID[star.primaryId] = surround;
      stars.push(surround);
      planetsByStarID[star.primaryId] = [];
    });

    planetData.forEach(function (planet) {
      var star = planet.starId;
      if (!planetsByStarID[star]) planetsByStarID[star] = [];
      planetsByStarID[star].push(planet);
    });
  }

  function createHighlightSprite() {
    return new THREE.Sprite(SPRITE_MATERIAL);
  }

  function setOffset(raw, current, offset) {
    if (!raw || !offset || !current) return;
    current.x = raw.x - offset.x;
    current.y = raw.y - offset.y;
    current.z = raw.z - offset.z;
  }

  function currentOffset(position) {
    var pos = new THREE.Vector3();
    pos.add(position);
    if (currentSystem) pos.add(currentSystem.star.objectData.cartesianCoordsInLys);
    return pos;
  }

  function select(mesh) {
    if (!mesh) return;

    var newTarget = mesh.objectData;

    if (isStar(mesh)) {
      var offset = mesh.objectData.cartesianCoordsInLys || { x:0, y:0, z:0 };
      stars.forEach(function (e) {
        if (e.objectData.cartesianCoordsInLys) setOffset(e.objectData.cartesianCoordsInLys, e.position, offset);
      });
      setOffset(currentOffset(camera.position), camera.position, offset);
      setOffset(ZERO, solMarker.mesh.position, offset);
    }

    if (newTarget != null) {
      var newTargetPrimaryId = newTarget.primaryId;

      if (newTargetPrimaryId != currentObjectPrimaryId) {
        $('#info-header').text(newTarget.properName);

        var infoTable = $('#info-table');
        infoTable.empty();

        infoTable
          .append($('<tr></tr>').append($('<td class="overlay-header"></td>').text('Characteristics')))
          .append(row("Radius", getValue(newTarget, 'radius')));

        if (newTarget.type == "STAR" || newTarget.type == "VIRTUAL_STAR") {
          infoTable
            .append(row("Class", newTarget.rawStellarClassification || "Unknown"))
            .append(row("Temperature", getValue(newTarget, 'temperatureEstimate') || "N/A"))
            .append(row("Distance (Sol)", getValue(newTarget, 'solDistance') || "Unknown"))
            .append(row("Right ascension", getValue(newTarget, 'rightAscensionRadians') || "Unknown"))
            .append(row("Declination", getValue(newTarget, 'declinationRadians') || "Unknown"))
            .append(row("Abs Magnitude", getValue(newTarget, 'absoluteMagnitude') || "Unknown"))
            .append(row("", ""))
            .append($('<tr></tr>').append($('<td class="overlay-header"></td>').text('Identifiers')))
            .append(row("Proper Name", newTarget.properName || "Unnamed Star"))
            .append(row("Hipparcos", (newTarget.identifiers && newTarget.identifiers.hipparcosId) || "Unknown"))
            .append(row("Henry Draper", (newTarget.identifiers && newTarget.identifiers.henryDraperId) || "Unknown"))
            .append(row("Harvard Revised", (newTarget.identifiers && newTarget.identifiers.harvardRevised) || "Unknown"))
            .append(row("Gliese", (newTarget.identifiers && newTarget.identifiers.glieseId) || "Unknown"))
            .append(row("Bayer Flamsteed", bfName(newTarget.identifiers && newTarget.identifiers.bayerFlamsteed) || "Unknown"));
        } else {
          infoTable
            .append(row("Mass", getValue(newTarget, 'massKg') || "Unknown"))
            .append(row("Density", getValue(newTarget, 'densityGcc') || "Unknown"))
            .append(row("Orbital Period", getValue(newTarget, 'orbitalPeriodDays') || "Unknown"))
            .append(row("Semi-Major axis", getValue(newTarget, 'semiMajorAxisLys') || "Unknown"))
            .append(row("Semi-Minor axis", getValue(newTarget, 'semiMinorAxisLys') || "Unknown"))
            .append(row("Inclination", getValue(newTarget, 'inclination') || "Unknown"))
            .append(row("Lon asc node", getValue(newTarget, 'longAscendingNode') || "Unknown"))
            .append(row("Arg periapsis", getValue(newTarget, 'argumentPeriapsis') || "Unknown"));
        }

        var prevTargetMesh = currentObjectMesh;
        updateCurrentTargets(mesh);
        updateTarget(prevTargetMesh);
        doReassign(currentObjectMesh);
      }
    }
  }

  function bfName(bayerFlamsteed) {
    if (bayerFlamsteed) return bayerFlamsteed.prettyName;
    return "";
  }

  function isSol(mesh) {
    return mesh.objectData.primaryId == 1;
  }

  function updateCurrentTargets(mesh) {
    currentObjectMesh = mesh;
    currentObjectPrimaryId = mesh.objectData.primaryId;

    if (mesh.objectData.type == "STAR" || mesh.objectData.type == "VIRTUAL_STAR") {
      if (currentSystem && currentSystem.star.objectData.primaryId == mesh.objectData.primaryId) return;

      var prevSystem = currentSystem;

      currentSystem = new System(
        mesh,
        ZERO,
        planetsByStarID[mesh.objectData.primaryId] || [],
        solMarker.mesh.position
      );

      if (isSol(mesh)) currentSystem.object.rotateY(23.5 * Math.PI / 180);

      if (prevSystem) {
        updateHighlight(prevSystem.star);
        scene.remove(prevSystem.object);
      }

      updateHighlight(currentSystem.star);
      scene.add(currentSystem.object);
    }
  }

  function row(name, value) {
    return $('<tr></tr>')
      .append($('<td></td>').text(name))
      .append($('<td></td>').text(value).addClass('info-element'));
  }

  function getValue(data, element) {
    var elem = data[element];
    if (!elem) return "Unknown";
    if (!elem.source) return elem;
    if (elem.source == "DEFAULT") return "?";
    return formatObjValue(elem);
  }

  function formatObjValue(elem) {
    var objValue = elem.value;
    var quantity = objValue.quantity;

    if (objValue.unit == 'LY') return prettyDistance(quantity);
    if (objValue.unit == 'DAY') return quantity + ' days';
    if (objValue.unit == 'KG') return prettyMass(quantity, elem.measurementQualifier);
    if (objValue.unit == 'DEGREE_GEOM') return prettyDegree(quantity);
    if (objValue.unit == 'RADIAN') return prettyDegree(quantity * 57.2958);
    if (objValue.unit == 'MV') return prettyMagnitude(quantity);
    if (objValue.unit == 'K') return prettyTemperature(quantity);
    if (objValue.unit == 'G_PER_CC') return prettyDensity(quantity);
    if (objValue.unit == 'NONE') return quantity;
  }

  function prettyDensity(gPerCc) { return gPerCc.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' g/cc'; }
  function prettyTemperature(k) { return k.toLocaleString('en-US', {maximumSignificantDigits: 3}) + 'K'; }
  function prettyMagnitude(mv) { return mv.toLocaleString('en-US', {maximumSignificantDigits: 3}) + 'Mv'; }
  function prettyDegree(degrees) { return degrees.toLocaleString('en-US', {maximumSignificantDigits: 3}) + '°'; }
  function prettyMass(mass, qualifier) {
    var str = (mass / 5.9722e24).toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' M⊕';
    if (qualifier == 'Msini') str += " (Msini)";
    return str;
  }
  function prettyDistance(lys) {
    if (lys > .01) return lys.toFixed(2) + ' ly';
    var distKM = lys * 9.461e12;
    var distAU = distKM / 1.496e8;
    if (distAU > .01) return distAU.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' AU';
    return distKM.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' km';
  }

  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    render();
  }

  function animate() { render(); requestAnimationFrame(animate); }

  function render() {
    var delta = clock.getDelta();
    uniforms.time.value += 0.003 * delta;

    if (controlMode == 'orbit') orbitControls.update(delta);
    else if (controlMode == 'free') freeLookControls.update(delta);
    else if (controlMode == 'tween') tweenControls.update(delta);

    getMouseoverStar();
    if (tooltip) tooltip.updateTo(camera);

    selector.updateTo(camera, delta);
    solMarker.updateTo(camera, delta);

    if (currentSystem) {
      var currentStar = currentSystem.star;
      if (currentStar) {
        (currentStar.objectData.nearbyObjectIDs || []).forEach(function (e) {
          var nearStar = starsByID[e];
          if (!nearStar) return;
          var distance = camera.position.distanceTo(nearStar.position) * .3;
          var childUniform = nearStar.material.uniforms;
          if (childUniform.scale.value != distance) {
            var scale = Math.min(distance, nearStar.objectData.radius.value.quantity * 3000000);
            setStarScale(nearStar, scale);
          }
        });
      }

      var newDistance = prettyDistance(camera.position.distanceTo(currentObjectMesh.position));
      if (lastDistance != newDistance) {
        lastDistance = newDistance;
        distanceHeader.text(newDistance);
      }
    }

    renderer.render(scene, camera);
  }

  function setStarScale(star, scale) {
    star.material.uniforms.scale.value = scale;
    star.scale.x = star.scale.y = star.scale.z = scale;
  }

  function resetStarScale(star) {
    star.material.uniforms.scale.value = star.objectData.radius.value.quantity * 3000000;
    var scale = 7.35355e-8 * 8000000;
    star.scale.set(scale, scale, scale);
  }

  canvas.addEventListener('contextmenu', function (event) { event.preventDefault(); }, false);
  canvas.addEventListener('mousemove', bind(orbitControls.onMouseMove, freeLookControls.onMouseMove), false);
  canvas.addEventListener('mousedown', bind(orbitControls.onMouseDown, freeLookControls.onMouseDown), false);
  canvas.addEventListener('mousewheel', bind(orbitControls.onMouseWheel, freeLookControls.onMouseWheel), false);
  canvas.addEventListener('DOMMouseScroll', bind(orbitControls.onMouseWheel, freeLookControls.onMouseWheel), false);
  canvas.addEventListener('mouseup', bind(orbitControls.onMouseUp, freeLookControls.onMouseUp), false);
  canvas.addEventListener('keydown', bind(orbitControls.onKeyDown, freeLookControls.onKeyDown), false);
  canvas.addEventListener('keyup', bind(orbitControls.onKeyUp, freeLookControls.onKeyUp), false);

  function bind(orbitFn, freeFn) {
    return function () {
      if (controlMode === 'free') freeFn.apply(freeLookControls, arguments);
      else if (controlMode === 'orbit') orbitFn.apply(orbitControls, arguments);
    };
  }

  var mouseDownX = 0;
  var mouseDownY = 0;
  function setmouseDown(event) { mouseDownX = event.clientX; mouseDownY = event.clientY; }

  window.addEventListener('resize', onWindowResize, false);
  canvas.addEventListener('mousemove', setMouseXY, false);
  canvas.addEventListener('mousedown', setmouseDown, false);
  canvas.addEventListener('mouseup', onMouseClick, false);

  var loader = new THREE.FontLoader();

  // ========= Catalog helpers (NO caching) =========
  const catalogStatusEl  = document.getElementById("catalogStatus");
  const loadCatalogBtn   = document.getElementById("loadCatalogBtn");
  const clearCatalogBtn  = document.getElementById("clearCatalogBtn");
  const catalogFileInput = document.getElementById("catalogFileInput");
  const starmapListEl    = document.getElementById("starmapList");

  const STARMAP_INDEX_URL = "https://xtdevelopment.net/chat-proxy/starmaps/starmaps.php";
  let mapAlive = false;

  function getHashCatalogURL() {
    if (!window.location.hash) return null;
    const raw = window.location.hash.substring(1).trim();
    if (!raw) return null;
    const decoded = decodeURIComponent(raw);
    if (/^https?:\/\//i.test(decoded)) return decoded;
    return null;
  }

  function prettyBytes(bytes) {
    if (bytes == null) return "";
    const units = ["B","KB","MB","GB","TB"];
    let b = bytes, i = 0;
    while (b >= 1024 && i < units.length-1) { b /= 1024; i++; }
    const digits = (i === 0) ? 0 : 1;
    return b.toFixed(digits) + units[i];
  }

  function renameSolIfCustom(catalogObj) {
    if (!catalogObj || !Array.isArray(catalogObj.stars)) return catalogObj;
    const rand = Math.floor(Math.random() * 900000) + 100000;
    catalogObj.stars.forEach(function(s){
      if (String(s.primaryId) === "1") {
        s.properName = "Virtual Sol Outpost " + rand;
      }
    });
    return catalogObj;
  }

  function resetCatalogScene() {
    try { if (tooltip) { scene.remove(tooltip.object); tooltip = null; } } catch(e){}
    try { if (lineSegment) { scene.remove(lineSegment); lineSegment = null; } } catch(e){}
    try { removeVirtualStars(); } catch(e){}

    if (currentSystem) {
      try { scene.remove(currentSystem.object); } catch(e){}
      currentSystem = null;
    }

    stars.forEach(function (s) { try { scene.remove(s); } catch(e){} });

    stars = [];
    starsByID = {};
    planetsByStarID = {};
    visibleStars = [];
    visibleStarsByName = {};
    currentObjectMesh = null;
    currentObjectPrimaryId = "";
  }

  function validateCatalogObject(obj) {
    if (!obj || typeof obj !== "object") throw new Error("Catalog is not an object.");
    if (!Array.isArray(obj.stars)) throw new Error("Catalog missing stars[] array.");
    if (!obj.planets) obj.planets = [];

    obj.stars.forEach(function(s, idx){
      if (typeof s.primaryId === "undefined") s.primaryId = idx + 1;
      if (!s.type) s.type = "STAR";
      if (!s.properName) s.properName = "Star " + s.primaryId;
      if (!s.cartesianCoordsInLys) s.cartesianCoordsInLys = { x:0, y:0, z:0 };
      if (!s.radius) {
        s.radius = { source:"INFERRED", value:{ unit:"LY", quantity:7.5e-8 } };
      }
      if (!s.solDistance) {
        var d = Math.sqrt(
          s.cartesianCoordsInLys.x*s.cartesianCoordsInLys.x +
          s.cartesianCoordsInLys.y*s.cartesianCoordsInLys.y +
          s.cartesianCoordsInLys.z*s.cartesianCoordsInLys.z
        );
        s.solDistance = { source:"INFERRED", value:{ unit:"LY", quantity:d } };
      }
      if (!s.temperatureEstimate) {
        s.temperatureEstimate = { source:"DEFAULT", value:{ unit:"K", quantity:5000 } };
      }
      if (!s.nearbyObjectIDs) s.nearbyObjectIDs = [];
      if (!s.identifiers) s.identifiers = {};
    });

    return obj;
  }

  function applyCatalogObject(parsed, isCustom) {
    if (!mapAlive) {
      starData   = parsed.stars || [];
      planetData = parsed.planets || [];
      return;
    }

    resetCatalogScene();

    starData   = parsed.stars || [];
    planetData = parsed.planets || [];

    initializeobjectData();
    updateobjectData();

    if (catalogStatusEl) {
      catalogStatusEl.style.color = "#8f8";
      catalogStatusEl.textContent =
        "Loaded catalog (" + starData.length + " stars, " + planetData.length + " planets)." +
        (isCustom ? " (custom)" : "");
    }
  }

  function cacheBust(url) {
    const ts = Date.now();
    return url + (url.indexOf("?") === -1 ? "?" : "&") + "ts=" + ts;
  }

  function loadCatalogFromURL(url, isCustom) {
    if (catalogStatusEl) {
      catalogStatusEl.style.color = "#ffb";
      catalogStatusEl.textContent = "Loading catalog...";
    }

    return $.ajax({
      type: "GET",
      dataType: "text",
      cache: false,
      url: cacheBust(url),
      success: function (data) {
        try {
          var obj = JSON.parse(data);

          if (isCustom) obj = renameSolIfCustom(obj);

          var parsed = validateCatalogObject(obj);
          applyCatalogObject(parsed, !!isCustom);

          if (!isCustom && catalogStatusEl && mapAlive) {
            catalogStatusEl.style.color = "#cfcfcf";
            catalogStatusEl.textContent = "Using server catalog.";
          }
        } catch (e) {
          if (catalogStatusEl) {
            catalogStatusEl.style.color = "#f88";
            catalogStatusEl.textContent = "Invalid catalog JSON.";
          }
        }
      },
      error: function () {
        if (catalogStatusEl) {
          catalogStatusEl.style.color = "#f88";
          catalogStatusEl.textContent = "Catalog failed to load.";
        }
      }
    });
  }

  // File picker
  if (loadCatalogBtn && catalogFileInput) {
    loadCatalogBtn.addEventListener("click", function() {
      catalogFileInput.value = "";
      catalogFileInput.click();
    });

    catalogFileInput.addEventListener("change", function(ev) {
      var file = ev.target.files && ev.target.files[0];
      if (!file) return;

      var reader = new FileReader();
      reader.onload = function() {
        try {
          var raw = reader.result;
          var obj = JSON.parse(raw);
          obj = renameSolIfCustom(obj); // file picker is always custom
          var parsed = validateCatalogObject(obj);
          applyCatalogObject(parsed, true);
        } catch(e) {
          if (catalogStatusEl) {
            catalogStatusEl.style.color = "#f88";
            catalogStatusEl.textContent = "Invalid catalog JSON: " + e.message;
          }
        }
      };
      reader.readAsText(file);
    });
  }

  // Reload default LOCAL catalog
  if (clearCatalogBtn) {
    clearCatalogBtn.addEventListener("click", function () {
      if (history && history.replaceState) {
        history.replaceState(null, "", window.location.pathname + window.location.search);
      }
      loadCatalogFromURL(DEFAULT_CATALOG_URL, false);
    });
  }

  // Starmap list with sizes (tolerant)
  function refreshStarmapList() {
    if (!starmapListEl) return;
    starmapListEl.innerHTML = '<div style="color:#888;">Loading list...</div>';

    fetch(cacheBust(STARMAP_INDEX_URL), { cache: "no-store" })
      .then(function(r){ return r.json(); })
      .then(function(items){
        starmapListEl.innerHTML = "";

        if (!items || !items.length) {
          starmapListEl.innerHTML = '<div style="color:#888;">No starmaps found.</div>';
          return;
        }

        items.forEach(function(it){
          // support new {url,name,size} OR old "urlstring"
          var url  = (typeof it === "string") ? it : it.url;
          var name = (typeof it === "string")
            ? (it.split("/").pop())
            : (it.name || (url ? url.split("/").pop() : "unknown.txt"));
          var size = (typeof it === "string") ? "" : prettyBytes(it.size);

          if (!url) return;

          var row = document.createElement("div");
          row.className = "starmap-item";
          row.innerHTML =
            '<span class="starmap-name"></span>' +
            '<span class="starmap-size"></span>';

          row.querySelector(".starmap-name").textContent = name;
          row.querySelector(".starmap-size").textContent = size;

          row.dataset.url = url;
          row.onclick = function(){ loadCatalogFromURL(url, true); };

          starmapListEl.appendChild(row);
        });
      })
      .catch(function(){
        starmapListEl.innerHTML = '<div style="color:#f88;">Failed to load list.</div>';
      });
  }

  // ======= STARTUP: local default, hash overrides =======
  function loadInitialCatalog() {
    var hashURL = getHashCatalogURL();
    if (hashURL) return loadCatalogFromURL(hashURL, true);
    return loadCatalogFromURL(DEFAULT_CATALOG_URL, false);
  }

  $.when(
    loadInitialCatalog(),
    shaders.loaders()
  ).then(function () {
    loader.load('js/font.js', function (response) {
      font = response;
      initializeobjectData();
      animate();
      updateobjectData();

      mapAlive = true;
      refreshStarmapList();
    });
  });

  // ======= HASHCHANGE: load without full reload =======
  window.addEventListener("hashchange", function() {
    var hashURL = getHashCatalogURL();
    if (hashURL) loadCatalogFromURL(hashURL, true);
    else loadCatalogFromURL(DEFAULT_CATALOG_URL, false);
  });

  // Auto Explore
  let autoExploreMode = false;
  let autoExploreInterval;

  function toggleAutoExplore() {
    autoExploreMode = !autoExploreMode;

    if (autoExploreMode) {
      document.getElementById("autoExploreButton").innerText = "Stop Auto Explore";
      startAutoExplore();
    } else {
      document.getElementById("autoExploreButton").innerText = "Start Auto Explore";
      stopAutoExplore();
    }
  }

  function startAutoExplore() {
    autoExploreInterval = setInterval(function(){
      const randomStar = getRandomVisibleStar();
      if (randomStar) select(randomStar);
    }, getRandomInterval(7000, 13000));
  }

  function stopAutoExplore() {
    clearInterval(autoExploreInterval);
  }

  function getRandomVisibleStar() {
    const allStars = visibleStars.concat(virtualStars);
    return allStars[Math.floor(Math.random() * allStars.length)];
  }

  function getRandomInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  document.getElementById("autoExploreButton").addEventListener("click", toggleAutoExplore);
</script>

</body>
</html>
