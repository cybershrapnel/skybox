<!DOCTYPE html>
<html lang="en">
<head>
  <title>Digital Skybox</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <link rel="stylesheet" type="text/css" href="resources/css/jquery-ui.css">
  <link rel="stylesheet" type="text/css" href="css/uncharted.css">

  <script type="text/javascript" src="resources/jquery-2.0.0.min.js"></script>
  <script type="text/javascript" src="resources/tinycolor-min.js"></script>
  <script type="text/javascript" src="resources/jquery-ui.min.js"></script>
  <script src="resources/three.min.js"></script>
  <script src="resources/stats.js"></script>
  <script src="js/constants.js"></script>
  <script src="js/FreeLookControls.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/DynamicMarker.js"></script>
  <script src="js/TweenControls.js"></script>
  <script src="js/TooltipMarker.js"></script>
  <script src="js/System.js"></script>
  <script src="js/Shaders.js"></script>
  <script src="js/CircularQueue.js"></script>
  <script src="js/RollingAverage.js"></script>
  <script src="js/PlanetBuilder.js"></script>
  <script src="resources/Detector.js"></script>

  <!-- Catalog UI styles -->
  <style>
    /* make Characteristics + LOS + Nearest + Stats scroll inside the panel */
#infoPanel{
  max-height: 70vh;      /* tweak if you want more/less */
  overflow-y: auto;
  overflow-x: hidden;
  padding-right: 6px;    /* keeps scrollbar off your text */
  box-sizing: border-box;
}
#infoPanel::-webkit-scrollbar { width: 8px; }
#infoPanel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 6px; }
#infoPanel::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); }

    #catalogStatus {
      font-size: 11px;
      line-height: 1.3;
      margin-top: 6px;
      color: #cfcfcf;
      word-break: break-word;
    }
    .catalog-btn {
      margin: 4px 0;
      width: 100%;
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    #starmapListContainer {
      margin-top: 8px;
      max-height: 180px;
      overflow-y: auto;
      border: 1px solid #444;
      background: rgba(0,0,0,0.35);
      padding: 6px;
      font-size: 12px;
    }
    .starmap-item {
      padding: 6px 8px;
      margin: 2px 0;
      cursor: pointer;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
      display:flex;
      justify-content:space-between;
      gap:10px;
    }
    .starmap-item:hover {
      background: rgba(255,255,255,0.12);
    }
    .starmap-name {
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .starmap-size {
      color:#9aa;
      font-size:11px;
      white-space:nowrap;
    }

    /* ============================
       LOS (Line-of-sight) panel
       ============================ */
    #losContainer {
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px solid rgba(255,255,255,0.15);
      font-size: 12px;
    }
    #losHeader {
      font-weight: bold;
      margin-bottom: 4px;
      color: #9fd0ff;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }
    #losList {
      max-height: 140px;
      overflow-y: auto;
      border: 1px solid #333;
      background: rgba(0,0,0,0.35);
      padding: 4px;
      border-radius: 4px;
    }
    .los-item {
      padding: 4px 6px;
      margin: 2px 0;
      cursor: pointer;
      border-radius: 3px;
      background: rgba(255,255,255,0.05);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .los-item:hover {
      background: rgba(120,170,255,0.18);
    }
    .los-name {
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      flex:1;
    }
    .los-dist {
      font-size: 11px;
      color:#aac;
      white-space:nowrap;
    }
    .los-empty {
      color:#888;
      font-size:11px;
      padding:4px 6px;
    }

    /* ============================
       Nearest Stars panel
       ============================ */
    #nearestContainer {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.15);
      font-size: 12px;
    }
    #nearestHeader {
      font-weight: bold;
      margin-bottom: 4px;
      color: #b6ffa8;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }
    #nearestList {
      max-height: 190px;
      overflow-y: auto;
      border: 1px solid #333;
      background: rgba(0,0,0,0.35);
      padding: 4px;
      border-radius: 4px;
    }
    .nearest-item {
      padding: 4px 6px;
      margin: 2px 0;
      cursor: pointer;
      border-radius: 3px;
      background: rgba(255,255,255,0.05);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:8px;
    }
    .nearest-item:hover {
      background: rgba(120,255,170,0.18);
    }
    .nearest-name {
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      flex:1;
    }
    .nearest-dist {
      font-size: 11px;
      color:#9fb8a2;
      white-space:nowrap;
    }
    .nearest-empty {
      color:#888;
      font-size:11px;
      padding:4px 6px;
    }

    /* ============================
       Catalog / View Stats panel
       ============================ */
    #catalogStatsContainer {
      margin-top: 10px;
      padding-top: 8px;
      border-top: 1px solid rgba(255,255,255,0.15);
      font-size: 12px;
    }
    #catalogStatsHeader {
      font-weight: bold;
      margin-bottom: 4px;
      color: #ffd28a;
      font-size: 11px;
      letter-spacing: 0.3px;
      text-transform: uppercase;
    }
    #catalogStats {
      border: 1px solid #333;
      background: rgba(0,0,0,0.35);
      padding: 6px 8px;
      border-radius: 4px;
      line-height: 1.45;
      font-size: 12px;
      color: #ddd;
    }
    .stat-row {
      display:flex;
      justify-content:space-between;
      gap:8px;
      padding:2px 0;
      border-bottom: 1px dashed rgba(255,255,255,0.06);
    }
    .stat-row:last-child { border-bottom:none; }
    .stat-label { color:#bbb; }
    .stat-value { color:#fff; white-space:nowrap; }
  </style>
</head>

<body>

<div>
  <div id="selector">
    <h3><span id="info-header" class="accordion-header"></span><b> - <span id="distance-header"
                                                                           class="accordion-header"></span></b></h3>
    <div class="overlay-panel" id="infoPanel">
      <table>
        <tbody id="info-table"></tbody>
      </table>

      <!-- ✅ Line-of-sight list lives here -->
      <div id="losContainer">
        <div id="losHeader">Line of Sight Targets</div>
        <div id="losList">
          <div class="los-empty">Select a star to see neighbors in sightline…</div>
        </div>
      </div>

      <!-- ✅ Nearest stars list lives here -->
      <div id="nearestContainer">
        <div id="nearestHeader">Nearest Stars</div>
        <div id="nearestList">
          <div class="nearest-empty">Select a star to see nearest neighbors…</div>
        </div>
      </div>

      <!-- ✅ Catalog + View stats lives here -->
      <div id="catalogStatsContainer">
        <div id="catalogStatsHeader">Catalog / View Stats</div>
        <div id="catalogStats">
          <div class="stat-row"><span class="stat-label">Stars loaded (file)</span><span class="stat-value" id="statStarsLoaded">0</span></div>
          <div class="stat-row"><span class="stat-label">Planets loaded (file)</span><span class="stat-value" id="statPlanetsLoaded">0</span></div>
          <div class="stat-row"><span class="stat-label">Stars visible (range)</span><span class="stat-value" id="statStarsVisible">0</span></div>
          <div class="stat-row"><span class="stat-label">Planets visible (range)</span><span class="stat-value" id="statPlanetsVisible">0</span></div>
          <div class="stat-row"><span class="stat-label">Virtual stars loaded</span><span class="stat-value" id="statVirtualStarsLoaded">0</span></div>
        </div>
      </div>
    </div>

    <h3>Explore Local Skybox</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <label for="jump_to_list">Search: </label>
        <input id="jump_to_list" type="text">
      </div>
    </div>

    <h3>MEQUAVIS Location Data</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <font size=2>Current Phase Layer Location:</font> <br />1@2.1.1.1.1.1:0<br /><br />
        <input id="jump_to_list" type="text">
        <br />
        <font size=1><center> Obtain a valid MEQUAVIS hyperstack<br />
                             address from the NanoCheeZe JAVA app<br />
                             hint: There is only 1 active layer atm</center></font>
      </div>
    </div>

    <h3>Load and View in VR</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <a href="https://xtdevelopment.net/babylon">Launch in VR</a><br />
      </div>
    </div>

    <!-- Catalog panel -->
    <h3>Catalog</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <button id="loadCatalogBtn" class="catalog-btn">Load Local star_catalog.txt</button>
        <button id="clearCatalogBtn" class="catalog-btn">Reload Default Server Catalog</button>
        <input id="catalogFileInput" type="file" accept=".txt,.json,application/json,text/plain" style="display:none;">
        <div id="catalogStatus">Using server catalog.</div>

        <div id="starmapListContainer">
          <div style="font-size:11px;color:#bbb;margin-bottom:6px;">Available starmaps:</div>
          <div id="starmapList">
            <div style="color:#888;">List will load after map starts…</div>
          </div>
        </div>
      </div>
    </div>

    <h3>View</h3>
    <div class="overlay-panel">
      <table>
        <tbody>

        <tr class="header-row overlay-header">
          <td><b>Control Mode</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="control_mode" name="control_mode" action="#" method="POST">
              <div>
                <label><input type="radio" name="control_mode" value="orbit" checked></label> Orbit
                <label><input type="radio" name="control_mode" value="free"></label> Free Look
              </div>
            </form>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Virtual Stars</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <input type="checkbox" id="virtual_stars_checkbox" name="virtual_stars"> Enable Virtual Stars

            <!-- ✅ Virtual Stars amplifier slider (pos/neg multiplier on existing formula) -->
            <div style="margin-top:6px;">
              <label for="virtualStarAmpSlider" style="font-size:12px;">
                Virtual stars amplifier: <span id="virtualStarAmpValue">0%</span>
              </label>
              <input
                type="range"
                id="virtualStarAmpSlider"
                min="-100"
                max="300"
                step="1"
                value="0"
                style="width:100%;"
              />
              <div style="font-size:10px;color:#9aa;margin-top:2px;">
                0% = default density. Negative reduces, positive increases.
              </div>
            </div>

            <div>
              <button id="autoExploreButton">Toggle Auto Explore</button>
            </div>
            <!-- ✅ Drift jump feature button (only enabled when virtual stars are on) -->
            <div style="margin-top:6px;">
              <button id="virtualDriftButton" class="catalog-btn" disabled>
                Jump to Virtual Star Drift
              </button>
            </div>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Render Radius (Sol lys)</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="render_radius" name="render_radius" action="#" method="POST">
              <div>
                <label><input type="radio" name="render_radius" value="10"></label> 10
                <label><input type="radio" name="render_radius" value="25"></label> 25
                <label><input type="radio" name="render_radius" value="50"></label> 50
              </div>
              <div>
                <label><input type="radio" name="render_radius" value="75" checked></label> 75
                <label><input type="radio" name="render_radius" value="150"></label> 150
                <label><input type="radio" name="render_radius" value="200"></label> 200
              </div>
            </form>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Highlight</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="highlight_mode" name="highlight_mode" action="#" method="POST">
              <div>
                <label><input type="radio" name="highlight_mode" value="none" checked></label> None
                <label><input type="radio" name="highlight_mode" value="exoplanets"></label> Exoplanets
                <label><input type="radio" name="highlight_mode" value="all"></label> All
              </div>
            </form>
          </td>
        </tr>

        <!-- Menu collapse -->
        <tr class="header-row overlay-header">
          <td><b>Menu</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <button id="collapseMenuBtn" class="catalog-btn">Collapse menu</button>
          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>

<div id="attribution-overlay">
  <span id="page-counter"></span><br />
  <a href="https://mequavis.com" target="_top">MEQUAVIS.COM</a><br />
</div>

  <canvas id='webgl_canvas'></canvas>
</div>

<script>
  // visits counter
  const pageURL = encodeURIComponent(window.location.href);
  const counterURL = `https://www.xtdevelopment.net/hits/index.php?page=${pageURL}`;

  // DEFAULT CATALOG (LOCAL to skybox.nanocheeze.com)
  const DEFAULT_CATALOG_URL = "star_catalog.txt";  // relative = same server as skybox.html

  fetch(counterURL)
    .then(r => r.json())
    .then(data => {
      document.getElementById('page-counter').textContent =
        data.hits ? `Visits: ${data.hits}` : 'Visit count unavailable';
    })
    .catch(() => {
      document.getElementById('page-counter').textContent = 'Visit count unavailable';
    });

  // virtual stars
  let virtualStars = [];

  // ✅ amplifier slider elements + helpers
  const virtualStarsCheckbox = document.getElementById('virtual_stars_checkbox');
  const virtualDriftButton = document.getElementById('virtualDriftButton');
  const virtualStarAmpSlider = document.getElementById("virtualStarAmpSlider");
  const virtualStarAmpValue  = document.getElementById("virtualStarAmpValue");

  function getVirtualStarAmpMultiplier() {
    if (!virtualStarAmpSlider) return 1.0;
    const pct = parseFloat(virtualStarAmpSlider.value);
    if (isNaN(pct)) return 1.0;
    return Math.max(0, 1 + pct / 100);
  }

  function updateVirtualStarAmpDisplay() {
    if (virtualStarAmpValue && virtualStarAmpSlider) {
      const pct = parseFloat(virtualStarAmpSlider.value) || 0;
      virtualStarAmpValue.textContent = pct.toFixed(0) + "%";
    }
  }
  updateVirtualStarAmpDisplay();

  function createVirtualStars() {
    const baseNumStars = (100*renderRadius)-900;
    const ampMult = getVirtualStarAmpMultiplier();
    let numStars = Math.max(0, Math.floor(baseNumStars * ampMult));
    const maxDistance = renderRadius * 12;

      // ✅ guarantee at least 1 even if amp is 0 or negative
  if (numStars < 1) numStars = 1;

    for (let i = 0; i < numStars; i++) {
      const randomX = Math.random() * maxDistance - maxDistance / 2;
      const randomY = Math.random() * maxDistance - maxDistance / 2;
      const randomZ = Math.random() * maxDistance - maxDistance / 2;

      const clickableGeometry = new THREE.SphereGeometry(0.3, 8, 8);
      const starMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 0.8,
        transparent: true
      });
      const virtualStar = new THREE.Mesh(clickableGeometry, starMaterial);
      virtualStar.position.set(randomX, randomY, randomZ);

      const planetGeometry = new THREE.SphereGeometry(0.05, 8, 8);

      const getRandomColor = () => {
        const colorType = Math.random();
        if (colorType < 0.3) {
          if (Math.random() < 0.5) {
            return new THREE.Color(Math.random() * 0.5, Math.random() * 0.5 + 0.5, 1);
          } else {
            return new THREE.Color(1, Math.random() * 0.5, Math.random() * 0.5 + 0.5);
          }
        } else {
          const solidColors = [
            new THREE.Color(1, 0, 0),
            new THREE.Color(0, 1, 0),
            new THREE.Color(0, 0, 1),
            new THREE.Color(1, 0, 1)
          ];
          return solidColors[Math.floor(Math.random() * solidColors.length)];
        }
      };

      const planetMaterial = new THREE.MeshBasicMaterial({ color: getRandomColor() });
      const innerPlanet = new THREE.Mesh(planetGeometry, planetMaterial);
      innerPlanet.position.set(0, 0, 0);
      virtualStar.add(innerPlanet);

      const moonGeometry = new THREE.SphereGeometry(0.005, 8, 8);
      const moonMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
      const moon = new THREE.Mesh(moonGeometry, moonMaterial);
      moon.position.set(0, 0, 0);
      moon.objectData = { type: "MOON" };
      innerPlanet.add(moon);

      virtualStar.objectData = {
        primaryId: `virtual_star_${i}`,
        properName: `Virtual Star ${i + 1}`,
        type: "VIRTUAL_STAR",
        radius: { value: { quantity: 0.01 } },
        solDistance: { value: { quantity: Math.random() * renderRadius } },
        nearbyObjectIDs: [],
        cartesianCoordsInLys: { x: randomX, y: randomY, z: randomZ }
      };

      scene.add(virtualStar);
      stars.push(virtualStar);
      virtualStars.push(virtualStar);
    }

    // ✅ refresh view + stats + nearest list after adding
    updateobjectData();
    updateCatalogStats();
    updateNearestStarsList(currentObjectMesh);
    updateVirtualDriftButtonState();
  }

  function removeVirtualStars() {
    virtualStars.forEach(star => {
      scene.remove(star);
      const indexInStars = stars.indexOf(star);
      if (indexInStars !== -1) stars.splice(indexInStars, 1);
    });
    virtualStars = [];

    // ✅ refresh view + stats + nearest list after removing
    updateobjectData();
    updateCatalogStats();
    updateNearestStarsList(currentObjectMesh);
    updateVirtualDriftButtonState();
  }

  function updateVirtualDriftButtonState() {
    if (!virtualDriftButton) return;
    virtualDriftButton.disabled = !(virtualStarsCheckbox && virtualStarsCheckbox.checked);
  }

  if (virtualStarsCheckbox) {
    virtualStarsCheckbox.addEventListener('change', function() {
      if (this.checked) createVirtualStars();
      else removeVirtualStars();
      updateVirtualDriftButtonState();
    });
  }

  // ✅ live rebuild when amplifier moves (only if virtual stars enabled)
  if (virtualStarAmpSlider) {
    virtualStarAmpSlider.addEventListener("input", function() {
      updateVirtualStarAmpDisplay();
      if (virtualStarsCheckbox && virtualStarsCheckbox.checked) {
        removeVirtualStars();
        createVirtualStars();
      }
    });
  }

  if (virtualDriftButton) {
    virtualDriftButton.addEventListener('click', function() {
      if (!virtualStarsCheckbox || !virtualStarsCheckbox.checked) return;
      if (!virtualStars || !virtualStars.length) return;

      // nearest virtual star to camera = best "drift jump" feel
      let best = virtualStars[0];
      let bestD = Infinity;
      for (const v of virtualStars) {
        const d = camera.position.distanceTo(v.position);
        if (d < bestD) { bestD = d; best = v; }
      }

      select(best, { driftMode: true });
    });
  }

  updateVirtualDriftButtonState();
</script>

<script>
  // accordion + collapse
  $(function () {
    $("#selector").accordion({
      collapsible: true,
      animate: 100,
      heightStyle: 'panel',
      active: 4
    });

    let menuCollapsed = false;

    function collapseMenu() {
      const $acc = $("#selector");
      const $headers = $acc.children("h3");
      const $panels = $headers.next();

      $acc.accordion("option", "active", false);
      $headers.not(":first").hide();
      $panels.not(":first").hide();

      menuCollapsed = true;
    }

    function restoreMenu() {
      const $acc = $("#selector");
      const $headers = $acc.children("h3");
      const $panels = $headers.next();

      $headers.show();
      $panels.show();

      menuCollapsed = false;
      $acc.accordion("refresh");
    }

    $("#collapseMenuBtn").on("click", function(e){
      e.preventDefault();
      if (!menuCollapsed) collapseMenu();
    });

    $("#selector").children("h3").first().on("click", function(){
      if (menuCollapsed) restoreMenu();
    });
  });

  var distanceHeader = $("#distance-header");
  var lastDistance;

  if (!Detector.webgl) Detector.addGetWebGLMessage();

  var SURROUND_GEOMETRY = new THREE.SphereGeometry(1.0, 8, 8);
  var ZERO = new THREE.Vector3(0, 0, 0);

  var canvas = $("#webgl_canvas").get(0);
  var scene = new THREE.Scene();

  var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.0000000005, 10000);
  camera.position.set(0, 0, -35);
  camera.rotateZ(Math.PI);
  camera.rotateY(Math.PI);

  var intersectCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .01, 10000);

  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  var clock = new THREE.Clock();

  var solMarker = new DynamicMarker(new THREE.Vector3(0, 0, 0), SOL_MARKER_RADIUS, 0x0000FF, 0);

  var selector = new DynamicMarker(new THREE.Vector3(0, 0, 0), MARKER_RADIUS, 0x00b33c, Math.PI / 4);

  var lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff, depthWrite: false });

  var uniforms = { time: {type: "f", value: 1.0}, scale: {type: "f", value: 80} };

  var lineSegment;
  var tooltip;
  var tooltipObject;
  var font;

  var mouseX;
  var mouseY;
  var mouseMoved = false;

  var controlMode = '';
  var highlightMode = 'none';

  var renderer = new THREE.WebGLRenderer({ canvas: canvas, logarithmicDepthBuffer: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = true;

  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();

  var freeLookControls = new THREE.FreeLookControls(camera, canvas);
  var orbitControls = new THREE.OrbitControls(camera, canvas);
  var tweenControls = new THREE.TweenControls(camera);

  var shaders = new Shaders();

  var light = new THREE.AmbientLight(0x404040);
  scene.add(light);

  scene.add(camera);
  scene.add(intersectCamera);
  scene.add(solMarker.mesh);
  scene.add(selector.mesh);

  var starData;
  var planetData;

  var stars = [];
  var starsByID = {};
  var planetsByStarID = {};
  var visibleStars = [];
  var visibleStarsByName = {};
  var renderRadius = 75;

  // track last selected raw coords for stable offsets when no System is active (virtual stars)
  var lastSelectedStarRaw = { x:0, y:0, z:0 };

  $("#jump_to_list").keydown(function (e) {
    if (e.keyCode == 13) {
      e.preventDefault();
      select(visibleStarsByName[this.value]);
    }
  });

  $("#render_radius").click(function () {
    renderRadius = $('input[name=render_radius]:checked', '#render_radius').val();
    updateobjectData();
    updateCatalogStats(); // ✅ update stats when view range changes
    updateNearestStarsList(currentObjectMesh); // ✅ optional refresh
  });

  $('#control_mode').click(function () {
    controlMode = $('input[name=control_mode]:checked', '#control_mode').val();
    updateTarget();
  });

  $("#highlight_mode").click(function () {
    highlightMode = $('input[name=highlight_mode]:checked', '#highlight_mode').val();
    stars.forEach(function (starMesh) { updateHighlight(starMesh); });
  });

  var HIGHLIGHT_MAP = new THREE.TextureLoader().load("images/highlight.png");
  var SPRITE_MATERIAL = new THREE.SpriteMaterial({ map: HIGHLIGHT_MAP, depthWrite: false });

  /* ===========================================================
     ✅ Adaptive picking state (tiny star helper)
     =========================================================== */
  const BASE_PICK_PX = 10;           // normal pick radius
  const MAX_EXTRA_PICK_PX = 22;      // how much it can grow
  const PICK_GROW_PX_PER_SEC = 10;   // growth per second when wiggling
  const WIGGLE_PX_THRESH = 3;        // <= this counts as targeting wiggle

  let lastMoveT = performance.now();
  let lastMoveX = 0;
  let lastMoveY = 0;
  let smallMoveTime = 0; // seconds of micro-move / idle wiggle

  function updatePickState(x, y) {
    const now = performance.now();
    const dt = (now - lastMoveT) / 1000;
    const dx = x - lastMoveX;
    const dy = y - lastMoveY;
    const dist = Math.sqrt(dx*dx + dy*dy);

    if (dist <= WIGGLE_PX_THRESH) {
      smallMoveTime = Math.min(3, smallMoveTime + dt); // cap at ~3s
    } else {
      smallMoveTime = Math.max(0, smallMoveTime - dt*2); // decay faster
    }

    lastMoveT = now;
    lastMoveX = x;
    lastMoveY = y;
  }

  function currentPickPx() {
    const extra = Math.min(MAX_EXTRA_PICK_PX, smallMoveTime * PICK_GROW_PX_PER_SEC);
    return BASE_PICK_PX + extra;
  }

  function pickByScreenDistance(allStars, sx, sy, pickPx) {
    let best = null;
    let bestD = Infinity;

    for (const s of allStars) {
      if (!s || !s.position || !s.objectData) continue;

      const id = s.objectData.primaryId;
      if (id === currentObjectPrimaryId) continue;
      if (currentSystem && currentSystem.star && id === currentSystem.star.objectData.primaryId) continue;

      const p = s.position.clone().project(camera);
      if (p.z < -1 || p.z > 1) continue; // behind camera clip-ish

      const px = (p.x * 0.5 + 0.5) * window.innerWidth;
      const py = (-p.y * 0.5 + 0.5) * window.innerHeight;

      const d = Math.hypot(px - sx, py - sy);
      if (d <= pickPx && d < bestD) {
        bestD = d;
        best = s;
      }
    }
    return best;
  }

  function updateTarget(prevStarMesh) {
    var prevControlMode = controlMode;
    controlMode = 'tween';

    var finalZoom = function (approachTime) {
      return function () {
        tweenControls.setZoom(
          absolutePosition(currentObjectMesh),
          currentObjectMesh.objectData.radius.value.quantity * 10,
          approachTime,
          function () {
            if (currentSystem && isStar(currentObjectMesh) && currentObjectMesh.objectData.type === "STAR") {
              currentSystem.populatePlanets();
            }
            if (isStar(prevStarMesh)) {
              (prevStarMesh.objectData.nearbyObjectIDs || []).forEach(function (e) {
                resetStarScale(starsByID[e]);
              });
            }
            controlMode = (!prevControlMode || prevControlMode == 'tween') ? 'orbit' : prevControlMode;

            orbitControls.orbit(
              absolutePosition(currentObjectMesh),
              currentObjectMesh.objectData.radius.value.quantity * 2
            );
          }
        );
      };
    };

    if (isStar(currentObjectMesh)) {
      tweenControls.setZoom(absolutePosition(currentObjectMesh), MARKER_RADIUS, 2, finalZoom(1));
    } else {
      finalZoom(2)();
    }
  }

  // ✅ Drift jump feature (intentional “bug orbit”)
  function updateTargetDrift(prevStarMesh) {
    var prevControlMode = controlMode;
    controlMode = 'tween';

    const targetPos = absolutePosition(currentObjectMesh);
    const orbitR = Math.max(10, renderRadius * 0.6);

    tweenControls.setZoom(
      targetPos,
      orbitR,
      1.5,
      function () {
        controlMode = 'orbit';
        orbitControls.orbit(targetPos, orbitR);
      }
    );
  }

  function isStar(mesh) { return mesh && (mesh.objectData.type == "STAR" || mesh.objectData.type == "VIRTUAL_STAR"); }

  var currentObjectPrimaryId = "";
  var currentObjectMesh;
  var currentSystem;

  function reassignLabel(targetMesh) {
    if (!tooltipObject || tooltipObject.objectData.primaryId == targetMesh.objectData.primaryId) return;
    doReassign(targetMesh);
  }

  var labelCache = {};

  function absolutePosition(mesh) {
    scene.updateMatrixWorld();
    var vector = new THREE.Vector3();
    vector.setFromMatrixPosition(mesh.matrixWorld);
    return vector;
  }

  function doReassign(targetMesh) {
    tooltipObject = targetMesh;

    scene.remove(lineSegment);
    if (tooltip) scene.remove(tooltip.object);

    var targetPos = absolutePosition(targetMesh);
    var geometry = new THREE.Geometry();
    var currentObjPosition = absolutePosition(currentObjectMesh);

    geometry.vertices.push(currentObjPosition);
    geometry.vertices.push(targetPos);
    lineSegment = new THREE.Line(geometry, lineMaterial);

    var lineDistance = currentObjectMesh ? currentObjectMesh.position.distanceTo(targetPos) : 0;
    var label = targetMesh.objectData.properName || "Unnamed Star";
    var cacheKey = label + lineDistance;

    var radiusQuantity = (targetMesh.objectData.radius && targetMesh.objectData.radius.value && targetMesh.objectData.radius.value.quantity) || 0.01;

    if (!labelCache[cacheKey]) {
      labelCache[cacheKey] = new TooltipMarker(label, prettyDistance(lineDistance), radiusQuantity);
    }

    tooltip = labelCache[cacheKey];
    tooltip.object.position.set(targetPos.x, targetPos.y, targetPos.z);

    scene.add(lineSegment);
    scene.add(tooltip.object);

    tooltip.updateTo(camera);
  }

  function isRender(objectData) {
    return objectData.solDistance.value.quantity < renderRadius;
  }

  // ✅ Highlight safe for virtual star children (no child[0] assumptions)
  function createHighlightSprite() {
    const sp = new THREE.Sprite(SPRITE_MATERIAL);
    sp.userData.isHighlight = true;
    sp.name = "highlightSprite";
    return sp;
  }

  function findHighlightChild(starMesh) {
    if (!starMesh || !starMesh.children) return null;
    return starMesh.children.find(c => c && c.userData && c.userData.isHighlight);
  }

  function updateHighlight(starMesh) {
    const highlight = findHighlightChild(starMesh);

    if (highlightMode === 'none' ||
        (currentSystem && starMesh.objectData.primaryId === currentSystem.star.objectData.primaryId)) {
      if (highlight) starMesh.remove(highlight);
    } else if (highlightMode === 'exoplanets' && starMesh.objectData.type === "STAR") {
      if (planetsByStarID[starMesh.objectData.primaryId] &&
          planetsByStarID[starMesh.objectData.primaryId][0]) {
        if (!highlight) starMesh.add(createHighlightSprite());
      } else {
        if (highlight) starMesh.remove(highlight);
      }
    } else if (highlightMode === 'all' || starMesh.objectData.type === "VIRTUAL_STAR") {
      if (!highlight) starMesh.add(createHighlightSprite());
    }
  }

  function updateobjectData() {
    var renderedStars = {};
    visibleStars.forEach(function (e) { renderedStars[e.objectData.primaryId] = true; });

    visibleStars = [];
    visibleStarsByName = {};
    var nameList = [];

    stars.forEach(function (starMesh) {
      var data = starMesh.objectData;
      var starID = data.primaryId;
      var commonName = data.properName || ("Star " + starID);

      nameList.push(commonName);
      visibleStarsByName[commonName] = starMesh;

      if (isRender(data)) {
        visibleStars.push(starMesh);
        if (!renderedStars[starID]) scene.add(starMesh);
      } else {
        if (renderedStars[starID]) {
          scene.remove(starMesh);
          renderedStars[starID] = null;
        }
      }
    });

    if (currentSystem == null) {
      const defaultStar = starsByID[1] || stars[0];
      if (defaultStar) {
        select(defaultStar);
        const labelStar = starsByID[70667] || stars[1] || defaultStar;
        if (labelStar) reassignLabel(labelStar);
      }
    } else if (currentSystem && !renderedStars[currentSystem.star.primaryId]) {
      const fallback = starsByID[1] || stars[0];
      if (fallback) select(fallback);
    }

    $("#jump_to_list").autocomplete({ source: nameList, minLength: 4 });

    // ✅ keep stats fresh any time visibility recalcs
    updateCatalogStats();
  }

  function closestNonPrimaryObject(intersects, currentPrimary, currentStarPrimary) {
    if (intersects.length == 0) return null;

    var firstIntersect = intersects[0].object;
    var firstIntersectId = firstIntersect.objectData.primaryId;

    if (intersects.length == 1 && currentPrimary) {
      if (firstIntersectId == currentStarPrimary) return firstIntersect;
      if (firstIntersectId != currentPrimary) return firstIntersect;
    }

    var lookPoint = camera.position;
    var min = Number.MAX_VALUE;
    var best = null;

    intersects.forEach(function (e) {
      var screenDistance = e.object.position.distanceTo(e.point) / lookPoint.distanceTo(e.point);
      var intersectId = e.object.objectData.primaryId;

      if (screenDistance < min && intersectId != currentPrimary && intersectId != currentStarPrimary) {
        best = e.object;
        min = screenDistance;
      }
    });

    return best;
  }

  function getStarForPoint(x, y) {
    if (x && y) {
      mouse.x = (x / window.innerWidth) * 2 - 1;
      mouse.y = -(y / window.innerHeight) * 2 + 1;

      intersectCamera.position.copy(camera.position);
      intersectCamera.rotation.copy(camera.rotation);
      raycaster.setFromCamera(mouse, intersectCamera);

      if (currentSystem) {
        var last = closestNonPrimaryObject(
          raycaster.intersectObjects(currentSystem.selectable, false),
          currentObjectPrimaryId,
          currentSystem.star.objectData.primaryId
        );
        if (last) return currentSystem.objectsByID[last.objectData.primaryId];
      }

      var allStars = visibleStars.concat(virtualStars);
      var lastStar = closestNonPrimaryObject(
        raycaster.intersectObjects(allStars, false),
        currentObjectPrimaryId,
        null
      );

      if (lastStar) return lastStar;

      if (tooltip) {
        var text = raycaster.intersectObjects(tooltip.scaleObj.children, false);
        if (text.length > 0) return tooltipObject;
      }

      /* ✅ screen-distance fallback with adaptive radius */
      const pickPx = currentPickPx();
      const fb = pickByScreenDistance(allStars, x, y, pickPx);
      if (fb) return fb;
    }
    return null;
  }

  function setMouseXY(event) {
    mouseX = event.clientX;
    mouseY = event.clientY;
    mouseMoved = true;
    updatePickState(mouseX, mouseY); // ✅ adaptive pick update
  }

  function consumeMouseMove() {
    if (!mouseMoved) return false;
    mouseMoved = false;
    return true;
  }

  function getMouseoverStar() {
    if (!freeLookControls.dragView && consumeMouseMove()) {
      var object = getStarForPoint(mouseX, mouseY);
      canvas.style.cursor = object ? 'pointer' : 'auto';
      if (object) reassignLabel(object);
    }
  }

  function onMouseClick(event) {
    const diffX = Math.abs(mouseDownX - event.clientX);
    const diffY = Math.abs(mouseDownY - event.clientY);
    const delta = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
    if (delta < 5) {
      const clickedStar = getStarForPoint(event.clientX, event.clientY);
      if (clickedStar) select(clickedStar);
    }
  }

  function initializeobjectData() {
    starData.forEach(function (star) {
      var tempQ = (star.temperatureEstimate && star.temperatureEstimate.value && star.temperatureEstimate.value.quantity) || 5000;

      var shaderSurround = new THREE.ShaderMaterial({
        vertexShader: shaders.coronaVertexShader,
        fragmentShader: shaders.coronaFragmentShader,
        uniforms: {
          scale: {type: "f", value: 0.0},
          temp: {type: "f", value: tempQ / 2}
        },
        transparent: true,
        depthWrite: false,
        polygonOffset: .1,
        usePolygonOffset: true
      });

      var surround = new THREE.Mesh(SURROUND_GEOMETRY, shaderSurround);
      surround.objectData = star;
      resetStarScale(surround);
      updateHighlight(surround);

      surround.position.x = star.cartesianCoordsInLys.x;
      surround.position.y = star.cartesianCoordsInLys.y;
      surround.position.z = star.cartesianCoordsInLys.z;

      starsByID[star.primaryId] = surround;
      stars.push(surround);
      planetsByStarID[star.primaryId] = [];
    });

    planetData.forEach(function (planet) {
      var star = planet.starId;
      if (!planetsByStarID[star]) planetsByStarID[star] = [];
      planetsByStarID[star].push(planet);
    });

    // ✅ update stats after init
    updateCatalogStats();
  }

  function setOffset(raw, current, offset) {
    if (!raw || !offset || !current) return;
    current.x = raw.x - offset.x;
    current.y = raw.y - offset.y;
    current.z = raw.z - offset.z;
  }

  function currentOffset(position) {
    var pos = new THREE.Vector3();
    pos.add(position);

    if (currentSystem && currentSystem.star && currentSystem.star.objectData.cartesianCoordsInLys) {
      pos.add(currentSystem.star.objectData.cartesianCoordsInLys);
    } else if (lastSelectedStarRaw) {
      pos.add(lastSelectedStarRaw);
    }

    return pos;
  }

  /* ===========================================================
     ✅ Line-of-sight listing
     =========================================================== */
  const losListEl = document.getElementById("losList");
  const losHeaderEl = document.getElementById("losHeader");
  const LOS_CONE_ANGLE_RAD = 0.015; // ~0.86 degrees
  const LOS_MAX_ITEMS = 14;

  function updateLineOfSightList(targetMesh) {
    if (!losListEl || !targetMesh) return;

    const camPos = camera.position.clone();
    const targetPos = targetMesh.position.clone();
    const dir = targetPos.clone().sub(camPos);
    const dirLen = dir.length();
    if (dirLen < 1e-9) return;
    dir.normalize();

    const allStars = visibleStars.concat(virtualStars);

    const hits = [];
    for (const s of allStars) {
      if (!s || !s.position || !s.objectData) continue;
      if (s.objectData.primaryId === targetMesh.objectData.primaryId) continue;

      const v = s.position.clone().sub(camPos);
      const vLen = v.length();
      if (vLen < 1e-9) continue;

      const vNorm = v.clone().divideScalar(vLen);
      let dot = vNorm.dot(dir);
      dot = Math.max(-1, Math.min(1, dot));

      const angle = Math.acos(dot);
      if (angle <= LOS_CONE_ANGLE_RAD) {
        const along = v.dot(dir); // signed distance along sightline
        hits.push({ mesh: s, along });
      }
    }

    hits.sort((a,b) => a.along - b.along);

    losListEl.innerHTML = "";
    if (!hits.length) {
      losListEl.innerHTML = '<div class="los-empty">No nearby stars along this sightline.</div>';
      return;
    }

    const trimmed = hits.slice(0, LOS_MAX_ITEMS);

    trimmed.forEach(h => {
      const m = h.mesh;
      const name = (m.objectData && m.objectData.properName) || ("Star " + m.objectData.primaryId);
      const dist = prettyDistance(Math.abs(h.along));

      const row = document.createElement("div");
      row.className = "los-item";
      row.dataset.primaryId = m.objectData.primaryId;

      const n = document.createElement("span");
      n.className = "los-name";
      n.textContent = name;

      const d = document.createElement("span");
      d.className = "los-dist";
      d.textContent = (h.along >= 0 ? "Ahead " : "Behind ") + dist;

      row.appendChild(n);
      row.appendChild(d);

      row.onclick = () => {
        const pid = row.dataset.primaryId;
        const target = starsByID[pid] || allStars.find(s2 => String(s2.objectData.primaryId) === String(pid));
        if (target) select(target);
      };

      losListEl.appendChild(row);
    });
  }

  /* ===========================================================
     ✅ Nearest stars listing (100 closest)
     - Sort by where we are
     - Filter by Sol-range visibility
     =========================================================== */
  const nearestListEl = document.getElementById("nearestList");
  const NEAREST_MAX_ITEMS = 100;

  function prettyLy(lys) {
    if (lys == null || isNaN(lys)) return "? ly";
    return lys.toFixed(3) + " ly";
  }

  function getBaseStarForNearest(targetMesh) {
    if (targetMesh && isStar(targetMesh)) return targetMesh;
    if (currentSystem && currentSystem.star && isStar(currentSystem.star)) return currentSystem.star;
    return null;
  }

  function updateNearestStarsList(targetMesh) {
    if (!nearestListEl) return;

    const baseStar = getBaseStarForNearest(targetMesh);
    if (!baseStar) {
      nearestListEl.innerHTML = '<div class="nearest-empty">Select a star to see nearest neighbors…</div>';
      return;
    }

    const basePos = baseStar.position.clone();

    const allStars = stars.slice(); // all loaded meshes (real + any virtual)
    const items = [];

    for (const s of allStars) {
      if (!s || !s.position || !s.objectData) continue;
      if (String(s.objectData.primaryId) === String(baseStar.objectData.primaryId)) continue;
      if (s.objectData.type !== "STAR" && s.objectData.type !== "VIRTUAL_STAR") continue;

      // ✅ FILTER: only include stars visible in Sol-range
      if (!isRender(s.objectData)) continue;

      const d = basePos.distanceTo(s.position); // ly units
      items.push({ mesh: s, dist: d });
    }

    items.sort((a,b) => a.dist - b.dist);

    nearestListEl.innerHTML = "";
    if (!items.length) {
      nearestListEl.innerHTML = '<div class="nearest-empty">No other stars loaded.</div>';
      return;
    }

    items.slice(0, NEAREST_MAX_ITEMS).forEach(it => {
      const m = it.mesh;
      const name = (m.objectData && m.objectData.properName) || ("Star " + m.objectData.primaryId);
      const distStr = prettyLy(it.dist);

      const row = document.createElement("div");
      row.className = "nearest-item";
      row.dataset.primaryId = m.objectData.primaryId;

      const n = document.createElement("span");
      n.className = "nearest-name";
      n.textContent = name;

      const d = document.createElement("span");
      d.className = "nearest-dist";
      d.textContent = distStr;

      row.appendChild(n);
      row.appendChild(d);

      row.onclick = () => {
        const pid = row.dataset.primaryId;
        const target = starsByID[pid] || stars.find(s2 => String(s2.objectData.primaryId) === String(pid));
        if (target) select(target);
      };

      nearestListEl.appendChild(row);
    });
  }

  /* ===========================================================
     ✅ Catalog / View Stats
     =========================================================== */
  const statStarsLoadedEl   = document.getElementById("statStarsLoaded");
  const statPlanetsLoadedEl = document.getElementById("statPlanetsLoaded");
  const statStarsVisibleEl  = document.getElementById("statStarsVisible");
  const statPlanetsVisibleEl= document.getElementById("statPlanetsVisible");
  const statVirtualStarsLoadedEl = document.getElementById("statVirtualStarsLoaded");

function updateCatalogStats() {
  const starsLoaded = (starData && starData.length) ? starData.length : 0;
  const planetsLoaded = (planetData && planetData.length) ? planetData.length : 0;

  const virtualStarsLoaded = (virtualStars && virtualStars.length) ? virtualStars.length : 0;

  const starsVisible = (visibleStars && visibleStars.length) ? visibleStars.length : 0;

  let planetsVisible = 0;
  if (visibleStars && visibleStars.length) {
    visibleStars.forEach(function(s){
      if (!s || !s.objectData) return;
      const sid = s.objectData.primaryId;
      const plist = planetsByStarID[sid];
      if (plist && plist.length) planetsVisible += plist.length;
    });
  }

  if (statStarsLoadedEl) statStarsLoadedEl.textContent = String(starsLoaded);
  if (statVirtualStarsLoadedEl) statVirtualStarsLoadedEl.textContent = String(virtualStarsLoaded);
  if (statPlanetsLoadedEl) statPlanetsLoadedEl.textContent = String(planetsLoaded);
  if (statStarsVisibleEl) statStarsVisibleEl.textContent = String(starsVisible);
  if (statPlanetsVisibleEl) statPlanetsVisibleEl.textContent = String(planetsVisible);
}


  function select(mesh, opts) {
    if (!mesh) return;
    opts = opts || {};
    const driftMode = !!opts.driftMode;

    var newTarget = mesh.objectData;

    if (isStar(mesh) && !driftMode) {
      var offset = mesh.objectData.cartesianCoordsInLys || { x:0, y:0, z:0 };
      lastSelectedStarRaw = offset;

      stars.forEach(function (e) {
        if (e.objectData.cartesianCoordsInLys) setOffset(e.objectData.cartesianCoordsInLys, e.position, offset);
      });
      setOffset(currentOffset(camera.position), camera.position, offset);
      setOffset(ZERO, solMarker.mesh.position, offset);
    }

    if (newTarget != null) {
      var newTargetPrimaryId = newTarget.primaryId;

      if (newTargetPrimaryId != currentObjectPrimaryId) {
        $('#info-header').text(newTarget.properName);

        var infoTable = $('#info-table');
        infoTable.empty();

        infoTable
          .append($('<tr></tr>').append($('<td class="overlay-header"></td>').text('Characteristics')))
          .append(row("Radius", getValue(newTarget, 'radius')));

        if (newTarget.type == "STAR" || newTarget.type == "VIRTUAL_STAR") {
          infoTable
            .append(row("Class", newTarget.rawStellarClassification || "Unknown"))
            .append(row("Temperature", getValue(newTarget, 'temperatureEstimate') || "N/A"))
            .append(row("Distance (Sol)", getValue(newTarget, 'solDistance') || "Unknown"))
            .append(row("Right ascension", getValue(newTarget, 'rightAscensionRadians') || "Unknown"))
            .append(row("Declination", getValue(newTarget, 'declinationRadians') || "Unknown"))
            .append(row("Abs Magnitude", getValue(newTarget, 'absoluteMagnitude') || "Unknown"))
            .append(row("", ""))
            .append($('<tr></tr>').append($('<td class="overlay-header"></td>').text('Identifiers')))
            .append(row("Proper Name", newTarget.properName || "Unnamed Star"))
            .append(row("Hipparcos", (newTarget.identifiers && newTarget.identifiers.hipparcosId) || "Unknown"))
            .append(row("Henry Draper", (newTarget.identifiers && newTarget.identifiers.henryDraperId) || "Unknown"))
            .append(row("Harvard Revised", (newTarget.identifiers && newTarget.identifiers.harvardRevised) || "Unknown"))
            .append(row("Gliese", (newTarget.identifiers && newTarget.identifiers.glieseId) || "Unknown"))
            .append(row("Bayer Flamsteed", bfName(newTarget.identifiers && newTarget.identifiers.bayerFlamsteed) || "Unknown"));
        } else {
          infoTable
            .append(row("Mass", getValue(newTarget, 'massKg') || "Unknown"))
            .append(row("Density", getValue(newTarget, 'densityGcc') || "Unknown"))
            .append(row("Orbital Period", getValue(newTarget, 'orbitalPeriodDays') || "Unknown"))
            .append(row("Semi-Major axis", getValue(newTarget, 'semiMajorAxisLys') || "Unknown"))
            .append(row("Semi-Minor axis", getValue(newTarget, 'semiMinorAxisLys') || "Unknown"))
            .append(row("Inclination", getValue(newTarget, 'inclination') || "Unknown"))
            .append(row("Lon asc node", getValue(newTarget, 'longAscendingNode') || "Unknown"))
            .append(row("Arg periapsis", getValue(newTarget, 'argumentPeriapsis') || "Unknown"));
        }

        var prevTargetMesh = currentObjectMesh;
        updateCurrentTargets(mesh);

        if (driftMode) updateTargetDrift(prevTargetMesh);
        else updateTarget(prevTargetMesh);

        doReassign(currentObjectMesh);

        updateLineOfSightList(currentObjectMesh);
        updateNearestStarsList(currentObjectMesh);
        updateCatalogStats();
      }
    }
  }

  function bfName(bayerFlamsteed) {
    if (bayerFlamsteed) return bayerFlamsteed.prettyName;
    return "";
  }

  function isSol(mesh) {
    return mesh.objectData.primaryId == 1;
  }

  // ✅ REAL stars only get System. Virtual stars stay simple to prevent drift bug.
  function updateCurrentTargets(mesh) {
    currentObjectMesh = mesh;
    currentObjectPrimaryId = mesh.objectData.primaryId;

    if (isStar(mesh) && mesh.objectData.cartesianCoordsInLys) {
      lastSelectedStarRaw = mesh.objectData.cartesianCoordsInLys;
    }

    if (mesh.objectData.type === "STAR") {
      if (currentSystem && currentSystem.star.objectData.primaryId == mesh.objectData.primaryId) return;

      var prevSystem = currentSystem;

      currentSystem = new System(
        mesh,
        ZERO,
        planetsByStarID[mesh.objectData.primaryId] || [],
        solMarker.mesh.position
      );

      if (isSol(mesh)) currentSystem.object.rotateY(23.5 * Math.PI / 180);

      if (prevSystem) {
        updateHighlight(prevSystem.star);
        scene.remove(prevSystem.object);
      }

      updateHighlight(currentSystem.star);
      scene.add(currentSystem.object);
      return;
    }

    if (mesh.objectData.type === "VIRTUAL_STAR") {
      if (currentSystem) {
        try {
          updateHighlight(currentSystem.star);
          scene.remove(currentSystem.object);
        } catch(e){}
        currentSystem = null;
      }
      updateHighlight(mesh);
    }
  }

  function row(name, value) {
    return $('<tr></tr>')
      .append($('<td></td>').text(name))
      .append($('<td></td>').text(value).addClass('info-element'));
  }

  function getValue(data, element) {
    var elem = data[element];
    if (!elem) return "Unknown";
    if (!elem.source) return elem;
    if (elem.source == "DEFAULT") return "?";
    return formatObjValue(elem);
  }

  function formatObjValue(elem) {
    var objValue = elem.value;
    var quantity = objValue.quantity;

    if (objValue.unit == 'LY') return prettyDistance(quantity);
    if (objValue.unit == 'DAY') return quantity + ' days';
    if (objValue.unit == 'KG') return prettyMass(quantity, elem.measurementQualifier);
    if (objValue.unit == 'DEGREE_GEOM') return prettyDegree(quantity);
    if (objValue.unit == 'RADIAN') return prettyDegree(quantity * 57.2958);
    if (objValue.unit == 'MV') return prettyMagnitude(quantity);
    if (objValue.unit == 'K') return prettyTemperature(quantity);
    if (objValue.unit == 'G_PER_CC') return prettyDensity(quantity);
    if (objValue.unit == 'NONE') return quantity;
  }

  function prettyDensity(gPerCc) { return gPerCc.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' g/cc'; }
  function prettyTemperature(k) { return k.toLocaleString('en-US', {maximumSignificantDigits: 3}) + 'K'; }
  function prettyMagnitude(mv) { return mv.toLocaleString('en-US', {maximumSignificantDigits: 3}) + 'Mv'; }
  function prettyDegree(degrees) { return degrees.toLocaleString('en-US', {maximumSignificantDigits: 3}) + '°'; }
  function prettyMass(mass, qualifier) {
    var str = (mass / 5.9722e24).toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' M⊕';
    if (qualifier == 'Msini') str += " (Msini)";
    return str;
  }
  function prettyDistance(lys) {
    if (lys > .01) return lys.toFixed(2) + ' ly';
    var distKM = lys * 9.461e12;
    var distAU = distKM / 1.496e8;
    if (distAU > .01) return distAU.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' AU';
    return distKM.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' km';
  }

  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    render();
  }

  function animate() { render(); requestAnimationFrame(animate); }

  function render() {
    var delta = clock.getDelta();
    uniforms.time.value += 0.003 * delta;

    if (controlMode == 'orbit') orbitControls.update(delta);
    else if (controlMode == 'free') freeLookControls.update(delta);
    else if (controlMode == 'tween') tweenControls.update(delta);

    getMouseoverStar();
    if (tooltip) tooltip.updateTo(camera);

    selector.updateTo(camera, delta);
    solMarker.updateTo(camera, delta);

    if (currentSystem) {
      var currentStar = currentSystem.star;
      if (currentStar) {
        (currentStar.objectData.nearbyObjectIDs || []).forEach(function (e) {
          var nearStar = starsByID[e];
          if (!nearStar) return;
          var distance = camera.position.distanceTo(nearStar.position) * .3;
          var childUniform = nearStar.material && nearStar.material.uniforms;
          if (!childUniform || !childUniform.scale) return;

          if (childUniform.scale.value != distance) {
            var scale = Math.min(distance, nearStar.objectData.radius.value.quantity * 3000000);
            setStarScale(nearStar, scale);
          }
        });
      }

      var newDistance = prettyDistance(camera.position.distanceTo(currentObjectMesh.position));
      if (lastDistance != newDistance) {
        lastDistance = newDistance;
        distanceHeader.text(newDistance);
      }
    }

    renderer.render(scene, camera);
  }

  // ✅ Scale safe for shader + non-shader stars
  function setStarScale(star, scale) {
    if (star.material && star.material.uniforms && star.material.uniforms.scale) {
      star.material.uniforms.scale.value = scale;
    }
    star.scale.x = star.scale.y = star.scale.z = scale;
  }

  function resetStarScale(star) {
    const rQ = (star.objectData &&
               star.objectData.radius &&
               star.objectData.radius.value &&
               star.objectData.radius.value.quantity) || 7.5e-8;

    if (star.material && star.material.uniforms && star.material.uniforms.scale) {
      star.material.uniforms.scale.value = rQ * 3000000;
    }

    var scale = 7.35355e-8 * 8000000;
    star.scale.set(scale, scale, scale);
  }

  canvas.addEventListener('contextmenu', function (event) { event.preventDefault(); }, false);
  canvas.addEventListener('mousemove', bind(orbitControls.onMouseMove, freeLookControls.onMouseMove), false);
  canvas.addEventListener('mousedown', bind(orbitControls.onMouseDown, freeLookControls.onMouseDown), false);
  canvas.addEventListener('mousewheel', bind(orbitControls.onMouseWheel, freeLookControls.onMouseWheel), false);
  canvas.addEventListener('DOMMouseScroll', bind(orbitControls.onMouseWheel, freeLookControls.onMouseWheel), false);
  canvas.addEventListener('mouseup', bind(orbitControls.onMouseUp, freeLookControls.onMouseUp), false);
  canvas.addEventListener('keydown', bind(orbitControls.onKeyDown, freeLookControls.onKeyDown), false);
  canvas.addEventListener('keyup', bind(orbitControls.onKeyUp, freeLookControls.onKeyUp), false);

  function bind(orbitFn, freeFn) {
    return function () {
      if (controlMode === 'free') freeFn.apply(freeLookControls, arguments);
      else if (controlMode === 'orbit') orbitFn.apply(orbitControls, arguments);
    };
  }

  var mouseDownX = 0;
  var mouseDownY = 0;
  function setmouseDown(event) { mouseDownX = event.clientX; mouseDownY = event.clientY; }

  window.addEventListener('resize', onWindowResize, false);
  canvas.addEventListener('mousemove', setMouseXY, false);
  canvas.addEventListener('mousedown', setmouseDown, false);
  canvas.addEventListener('mouseup', onMouseClick, false);

  var loader = new THREE.FontLoader();

  // ========= Catalog helpers (NO caching) =========
  const catalogStatusEl  = document.getElementById("catalogStatus");
  const loadCatalogBtn   = document.getElementById("loadCatalogBtn");
  const clearCatalogBtn  = document.getElementById("clearCatalogBtn");
  const catalogFileInput = document.getElementById("catalogFileInput");
  const starmapListEl    = document.getElementById("starmapList");

  const STARMAP_INDEX_URL = "https://xtdevelopment.net/chat-proxy/starmaps/starmaps.php";
  let mapAlive = false;

  function getHashCatalogURL() {
    if (!window.location.hash) return null;
    const raw = window.location.hash.substring(1).trim();
    if (!raw) return null;
    const decoded = decodeURIComponent(raw);
    if (/^https?:\/\//i.test(decoded)) return decoded;
    return null;
  }

  function prettyBytes(bytes) {
    if (bytes == null) return "";
    const units = ["B","KB","MB","GB","TB"];
    let b = bytes, i = 0;
    while (b >= 1024 && i < units.length-1) { b /= 1024; i++; }
    const digits = (i === 0) ? 0 : 1;
    return b.toFixed(digits) + units[i];
  }

  function renameSolIfCustom(catalogObj) {
    if (!catalogObj || !Array.isArray(catalogObj.stars)) return catalogObj;
    const rand = Math.floor(Math.floor(Math.random() * 900000) + 100000);
    catalogObj.stars.forEach(function(s){
      if (String(s.primaryId) === "1") {
        s.properName = "Virtual Sol Outpost " + rand;
      }
    });
    return catalogObj;
  }

  function resetCatalogScene() {
    try { if (tooltip) { scene.remove(tooltip.object); tooltip = null; } } catch(e){}
    try { if (lineSegment) { scene.remove(lineSegment); lineSegment = null; } } catch(e){}
    try { removeVirtualStars(); } catch(e){}

    if (currentSystem) {
      try { scene.remove(currentSystem.object); } catch(e){}
      currentSystem = null;
    }

    stars.forEach(function (s) { try { scene.remove(s); } catch(e){} });

    stars = [];
    starsByID = {};
    planetsByStarID = {};
    visibleStars = [];
    visibleStarsByName = {};
    currentObjectMesh = null;
    currentObjectPrimaryId = "";
  }

  function validateCatalogObject(obj) {
    if (!obj || typeof obj !== "object") throw new Error("Catalog is not an object.");
    if (!Array.isArray(obj.stars)) throw new Error("Catalog missing stars[] array.");
    if (!obj.planets) obj.planets = [];

    obj.stars.forEach(function(s, idx){
      if (typeof s.primaryId === "undefined") s.primaryId = idx + 1;
      if (!s.type) s.type = "STAR";
      if (!s.properName) s.properName = "Star " + s.primaryId;
      if (!s.cartesianCoordsInLys) s.cartesianCoordsInLys = { x:0, y:0, z:0 };
      if (!s.radius) {
        s.radius = { source:"INFERRED", value:{ unit:"LY", quantity:7.5e-8 } };
      }
      if (!s.solDistance) {
        var d = Math.sqrt(
          s.cartesianCoordsInLys.x*s.cartesianCoordsInLys.x +
          s.cartesianCoordsInLys.y*s.cartesianCoordsInLys.y +
          s.cartesianCoordsInLys.z*s.cartesianCoordsInLys.z
        );
        s.solDistance = { source:"INFERRED", value:{ unit:"LY", quantity:d } };
      }
      if (!s.temperatureEstimate) {
        s.temperatureEstimate = { source:"DEFAULT", value:{ unit:"K", quantity:5000 } };
      }
      if (!s.nearbyObjectIDs) s.nearbyObjectIDs = [];
      if (!s.identifiers) s.identifiers = {};
    });

    return obj;
  }

  function applyCatalogObject(parsed, isCustom) {
    if (!mapAlive) {
      starData   = parsed.stars || [];
      planetData = parsed.planets || [];
      return;
    }

    resetCatalogScene();

    starData   = parsed.stars || [];
    planetData = parsed.planets || [];

    initializeobjectData();
    updateobjectData();

    if (catalogStatusEl) {
      catalogStatusEl.style.color = "#8f8";
      catalogStatusEl.textContent =
        "Loaded catalog (" + starData.length + " stars, " + planetData.length + " planets)." +
        (isCustom ? " (custom)" : "");
    }

    // ✅ nearest list and stats after catalog changes
    updateNearestStarsList(currentObjectMesh);
    updateCatalogStats();
  }

  function cacheBust(url) {
    const ts = Date.now();
    return url + (url.indexOf("?") === -1 ? "?" : "&") + "ts=" + ts;
  }

  function loadCatalogFromURL(url, isCustom) {
    if (catalogStatusEl) {
      catalogStatusEl.style.color = "#ffb";
      catalogStatusEl.textContent = "Loading catalog...";
    }

    return $.ajax({
      type: "GET",
      dataType: "text",
      cache: false,
      url: cacheBust(url),
      success: function (data) {
        try {
          var obj = JSON.parse(data);

          if (isCustom) obj = renameSolIfCustom(obj);

          var parsed = validateCatalogObject(obj);
          applyCatalogObject(parsed, !!isCustom);

          if (!isCustom && catalogStatusEl && mapAlive) {
            catalogStatusEl.style.color = "#cfcfcf";
            catalogStatusEl.textContent = "Using server catalog.";
          }
        } catch (e) {
          if (catalogStatusEl) {
            catalogStatusEl.style.color = "#f88";
            catalogStatusEl.textContent = "Invalid catalog JSON.";
          }
        }
      },
      error: function () {
        if (catalogStatusEl) {
          catalogStatusEl.style.color = "#f88";
          catalogStatusEl.textContent = "Catalog failed to load.";
        }
      }
    });
  }

  // File picker
  if (loadCatalogBtn && catalogFileInput) {
    loadCatalogBtn.addEventListener("click", function() {
      catalogFileInput.value = "";
      catalogFileInput.click();
    });

    catalogFileInput.addEventListener("change", function(ev) {
      var file = ev.target.files && ev.target.files[0];
      if (!file) return;

      var reader = new FileReader();
      reader.onload = function() {
        try {
          var raw = reader.result;
          var obj = JSON.parse(raw);
          obj = renameSolIfCustom(obj); // file picker is always custom
          var parsed = validateCatalogObject(obj);
          applyCatalogObject(parsed, true);
        } catch(e) {
          if (catalogStatusEl) {
            catalogStatusEl.style.color = "#f88";
            catalogStatusEl.textContent = "Invalid catalog JSON: " + e.message;
          }
        }
      };
      reader.readAsText(file);
    });
  }

  // Reload default LOCAL catalog
  if (clearCatalogBtn) {
    clearCatalogBtn.addEventListener("click", function () {
      if (history && history.replaceState) {
        history.replaceState(null, "", window.location.pathname + window.location.search);
      }
      loadCatalogFromURL(DEFAULT_CATALOG_URL, false);
    });
  }

  // Starmap list with sizes (tolerant)
  function refreshStarmapList() {
    if (!starmapListEl) return;
    starmapListEl.innerHTML = '<div style="color:#888;">Loading list...</div>';

    fetch(cacheBust(STARMAP_INDEX_URL), { cache: "no-store" })
      .then(function(r){ return r.json(); })
      .then(function(items){
        starmapListEl.innerHTML = "";

        if (!items || !items.length) {
          starmapListEl.innerHTML = '<div style="color:#888;">No starmaps found.</div>';
          return;
        }

        items.forEach(function(it){
          // support new {url,name,size} OR old "urlstring"
          var url  = (typeof it === "string") ? it : it.url;
          var name = (typeof it === "string")
            ? (it.split("/").pop())
            : (it.name || (url ? url.split("/").pop() : "unknown.txt"));
          var size = (typeof it === "string") ? "" : prettyBytes(it.size);

          if (!url) return;

          var row = document.createElement("div");
          row.className = "starmap-item";
          row.innerHTML =
            '<span class="starmap-name"></span>' +
            '<span class="starmap-size"></span>';

          row.querySelector(".starmap-name").textContent = name;
          row.querySelector(".starmap-size").textContent = size;

          row.dataset.url = url;
          row.onclick = function(){ loadCatalogFromURL(url, true); };

          starmapListEl.appendChild(row);
        });
      })
      .catch(function(){
        starmapListEl.innerHTML = '<div style="color:#f88;">Failed to load list.</div>';
      });
  }

  // ======= STARTUP: local default, hash overrides =======
  function loadInitialCatalog() {
    var hashURL = getHashCatalogURL();
    if (hashURL) return loadCatalogFromURL(hashURL, true);
    return loadCatalogFromURL(DEFAULT_CATALOG_URL, false);
  }

  $.when(
    loadInitialCatalog(),
    shaders.loaders()
  ).then(function () {
    loader.load('js/font.js', function (response) {
      font = response;
      initializeobjectData();
      animate();
      updateobjectData();

      mapAlive = true;
      refreshStarmapList();

      // ✅ initial stats + nearest for first star
      updateCatalogStats();
      updateNearestStarsList(currentObjectMesh);
    });
  });

  // ======= HASHCHANGE: load without full reload =======
  window.addEventListener("hashchange", function() {
    var hashURL = getHashCatalogURL();
    if (hashURL) loadCatalogFromURL(hashURL, true);
    else loadCatalogFromURL(DEFAULT_CATALOG_URL, false);
  });

  // Auto Explore
  let autoExploreMode = false;
  let autoExploreInterval;

  function toggleAutoExplore() {
    autoExploreMode = !autoExploreMode;

    if (autoExploreMode) {
      document.getElementById("autoExploreButton").innerText = "Stop Auto Explore";
      startAutoExplore();
    } else {
      document.getElementById("autoExploreButton").innerText = "Start Auto Explore";
      stopAutoExplore();
    }
  }

  function startAutoExplore() {
    autoExploreInterval = setInterval(function(){
      const randomStar = getRandomVisibleStar();
      if (randomStar) select(randomStar);
    }, getRandomInterval(7000, 13000));
  }

  function stopAutoExplore() {
    clearInterval(autoExploreInterval);
  }

  function getRandomVisibleStar() {
    const allStars = visibleStars.concat(virtualStars);
    return allStars[Math.floor(Math.random() * allStars.length)];
  }

  function getRandomInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  document.getElementById("autoExploreButton").addEventListener("click", toggleAutoExplore);
</script>

</body>
</html>
