<!DOCTYPE html>
<html lang="en">
<head>
  <title>Digital Skybox</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

  <link rel="stylesheet" type="text/css" href="resources/css/jquery-ui.css">
  <link rel="stylesheet" type="text/css" href="css/uncharted.css">

  <script type="text/javascript" src="resources/jquery-2.0.0.min.js"></script>
  <script type="text/javascript" src="resources/tinycolor-min.js"></script>
  <script type="text/javascript" src="resources/jquery-ui.min.js"></script>
  <script src="resources/three.min.js"></script>
  <script src="resources/stats.js"></script>
  <script src="js/constants.js"></script>
  <script src="js/FreeLookControls.js"></script>
  <script src="js/OrbitControls.js"></script>
  <script src="js/DynamicMarker.js"></script>
  <script src="js/TweenControls.js"></script>
  <script src="js/TooltipMarker.js"></script>
  <script src="js/System.js"></script>
  <script src="js/Shaders.js"></script>
  <script src="js/CircularQueue.js"></script>
  <script src="js/RollingAverage.js"></script>
  <script src="js/PlanetBuilder.js"></script>
  <script src="resources/Detector.js"></script>
  <style>
    #catalogStatus {
      font-size: 11px;
      line-height: 1.3;
      margin-top: 6px;
      color: #cfcfcf;
      word-break: break-word;
    }
    .catalog-btn {
      margin: 4px 0;
      width: 100%;
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
    }
    #starmapListContainer {
      margin-top: 8px;
      max-height: 180px;
      overflow-y: auto;
      border: 1px solid #444;
      background: rgba(0,0,0,0.35);
      padding: 6px;
      font-size: 12px;
    }
    .starmap-item {
      padding: 6px 8px;
      margin: 2px 0;
      cursor: pointer;
      border-radius: 4px;
      background: rgba(255,255,255,0.05);
    }
    .starmap-item:hover {
      background: rgba(255,255,255,0.12);
    }
  </style>
</head>

<body>

<div>
  <div id="selector">
    <h3><span id="info-header" class="accordion-header"></span><b> - <span id="distance-header"
                                                                           class="accordion-header"></span></b></h3>
    <div class="overlay-panel">
      <table>
        <tbody id="info-table"></tbody>
      </table>
    </div>

    <h3>Explore Local Skybox</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <label for="jump_to_list">Search: </label>
        <input id="jump_to_list" type="text">
      </div>
    </div>

    <h3>MEQUAVIS Location Data</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <font size=2>Current Phase Layer Location:</font> <br />1@2.1.1.1.1.1:0<br /><br />
        <input id="jump_to_list" type="text">
        <br />
        <font size=1><center> Obtain a valid MEQUAVIS hyperstack<br />
                             address from the NanoCheeZe JAVA app<br />
                             hint: There is only 1 active layer atm</center></font>
      </div>
    </div>

    <h3>Load and View in VR</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <a href="https://xtdevelopment.net/babylon">Launch in VR</a><br />
      </div>
    </div>

    <h3>Catalog</h3>
    <div class="overlay-panel">
      <div class="ui-widget">
        <button id="loadCatalogBtn" class="catalog-btn">Load Local star_catalog.txt</button>
        <button id="clearCatalogBtn" class="catalog-btn">Reload Default Server Catalog</button>
        <input id="catalogFileInput" type="file" accept=".txt,.json,application/json,text/plain" style="display:none;">
        <div id="catalogStatus">Using server catalog.</div>

        <div id="starmapListContainer">
          <div style="font-size:11px;color:#bbb;margin-bottom:6px;">Available starmaps:</div>
          <div id="starmapList">
            <div style="color:#888;">List will load after map starts…</div>
          </div>
        </div>
      </div>
    </div>

    <h3>View</h3>
    <div class="overlay-panel">
      <table>
        <tbody>
        <tr class="header-row overlay-header">
          <td><b>Control Mode</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="control_mode" name="control_mode" action="#" method="POST">
              <div>
                <label><input type="radio" name="control_mode" value="orbit" checked></label> Orbit
                <label><input type="radio" name="control_mode" value="free"></label> Free Look
              </div>
            </form>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Virtual Stars</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <input type="checkbox" id="virtual_stars_checkbox" name="virtual_stars"> Enable Virtual Stars
            <div>
              <button id="autoExploreButton">Toggle Auto Explore</button>
            </div>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Render Radius (Sol lys)</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="render_radius" name="render_radius" action="#" method="POST">
              <div>
                <label><input type="radio" name="render_radius" value="10"></label> 10
                <label><input type="radio" name="render_radius" value="25"></label> 25
                <label><input type="radio" name="render_radius" value="50"></label> 50
              </div>
              <div>
                <label><input type="radio" name="render_radius" value="75" checked></label> 75
                <label><input type="radio" name="render_radius" value="150"></label> 150
                <label><input type="radio" name="render_radius" value="200"></label> 200
              </div>
            </form>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Highlight</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <form id="highlight_mode" name="highlight_mode" action="#" method="POST">
              <div>
                <label><input type="radio" name="highlight_mode" value="none" checked></label> None
                <label><input type="radio" name="highlight_mode" value="exoplanets"></label> Exoplanets
                <label><input type="radio" name="highlight_mode" value="all"></label> All
              </div>
            </form>
          </td>
        </tr>

        <tr class="header-row overlay-header">
          <td><b>Menu</b></td>
        </tr>
        <tr class="child-row">
          <td>
            <button id="collapseMenuBtn" class="catalog-btn">Collapse menu</button>
          </td>
        </tr>

        </tbody>
      </table>
    </div>
  </div>

  <div id="attribution-overlay">
    <span id="page-counter"></span><br />
    <a href="https://mequavis.com">MEQUAVIS.COM</a><br />
  </div>

  <canvas id='webgl_canvas'></canvas>
</div>

<script>
  const pageURL = encodeURIComponent(window.location.href);
  const counterURL = `https://www.xtdevelopment.net/hits/index.php?page=${pageURL}`;

  fetch(counterURL)
      .then(response => response.json())
      .then(data => {
          if (data.hits) {
              document.getElementById('page-counter').textContent = `Visits: ${data.hits}`;
          } else {
              document.getElementById('page-counter').textContent = 'Visit count unavailable';
          }
      })
      .catch(error => {
          console.error('Error fetching visit count:', error);
          document.getElementById('page-counter').textContent = 'Visit count unavailable';
      });

  let virtualStars = [];

  function createVirtualStars() {
    const numStars = (100*renderRadius)-900;
    const maxDistance = renderRadius * 12;

    for (let i = 0; i < numStars; i++) {
      const randomX = Math.random() * maxDistance - maxDistance / 2;
      const randomY = Math.random() * maxDistance - maxDistance / 2;
      const randomZ = Math.random() * maxDistance - maxDistance / 2;

      const clickableGeometry = new THREE.SphereGeometry(0.3, 8, 8);
      const starMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        opacity: 0.8,
        transparent: true
      });
      const virtualStar = new THREE.Mesh(clickableGeometry, starMaterial);
      virtualStar.position.set(randomX, randomY, randomZ);

      const planetGeometry = new THREE.SphereGeometry(0.05, 8, 8);

      const getRandomColor = () => {
        const colorType = Math.random();
        if (colorType < 0.3) {
          if (Math.random() < 0.5) {
            return new THREE.Color(Math.random() * 0.5, Math.random() * 0.5 + 0.5, 1);
          } else {
            return new THREE.Color(1, Math.random() * 0.5, Math.random() * 0.5 + 0.5);
          }
        } else {
          const solidColors = [
            new THREE.Color(1, 0, 0),
            new THREE.Color(0, 1, 0),
            new THREE.Color(0, 0, 1),
            new THREE.Color(1, 0, 1)
          ];
          return solidColors[Math.floor(Math.random() * solidColors.length)];
        }
      };

      const planetMaterial = new THREE.MeshBasicMaterial({ color: getRandomColor() });
      const innerPlanet = new THREE.Mesh(planetGeometry, planetMaterial);

      innerPlanet.position.set(0, 0, 0);
      virtualStar.add(innerPlanet);

      const moonGeometry = new THREE.SphereGeometry(0.005, 8, 8);
      const moonMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
      const moon = new THREE.Mesh(moonGeometry, moonMaterial);

      moon.position.set(0, 0, 0);
      moon.objectData = { type: "MOON" };
      innerPlanet.add(moon);

      virtualStar.objectData = {
        primaryId: `virtual_star_${i}`,
        properName: `Virtual Star ${i + 1}`,
        type: "VIRTUAL_STAR",
        radius: { value: { quantity: 0.01 } },
        solDistance: { value: { quantity: Math.random() * renderRadius } },
        nearbyObjectIDs: [],
        cartesianCoordsInLys: { x: randomX, y: randomY, z: randomZ }
      };

      scene.add(virtualStar);
      stars.push(virtualStar);
      virtualStars.push(virtualStar);
    }
  }

  function removeVirtualStars() {
    virtualStars.forEach(star => {
      scene.remove(star);
      const indexInStars = stars.indexOf(star);
      if (indexInStars !== -1) {
        stars.splice(indexInStars, 1);
      }
    });
    virtualStars = [];
  }

  document.getElementById('virtual_stars_checkbox').addEventListener('change', function() {
    if (this.checked) {
      createVirtualStars();
    } else {
      removeVirtualStars();
    }
  });
</script>

<script>
  $(function () {
    // Catalog tab open on start (index 4)
    $("#selector").accordion({
      collapsible: true,
      animate: 100,
      heightStyle: 'panel',
      active: 4
    });

    // Collapse menu behavior
    let menuCollapsed = false;

    function collapseMenu() {
      const $acc = $("#selector");
      const $headers = $acc.children("h3");
      const $panels = $headers.next();

      $acc.accordion("option", "active", false);

      $headers.not(":first").hide();
      $panels.not(":first").hide();

      menuCollapsed = true;
    }

    function restoreMenu() {
      const $acc = $("#selector");
      const $headers = $acc.children("h3");
      const $panels = $headers.next();

      $headers.show();
      $panels.show();

      menuCollapsed = false;
      $acc.accordion("refresh");
    }

    $("#collapseMenuBtn").on("click", function(e){
      e.preventDefault();
      if (!menuCollapsed) collapseMenu();
    });

    $("#selector").children("h3").first().on("click", function(){
      if (menuCollapsed) restoreMenu();
    });
  });

  var distanceHeader = $("#distance-header");
  var lastDistance;

  if (!Detector.webgl) Detector.addGetWebGLMessage();

  var SURROUND_GEOMETRY = new THREE.SphereGeometry(1.0, 8, 8);
  var ZERO = new THREE.Vector3(0, 0, 0);

  var canvas = $("#webgl_canvas").get(0);
  var scene = new THREE.Scene();

  var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.0000000005, 10000);
  camera.position.set(0, 0, -35);
  camera.rotateZ(Math.PI);
  camera.rotateY(Math.PI);

  var intersectCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, .01, 10000);

  var windowHalfX = window.innerWidth / 2;
  var windowHalfY = window.innerHeight / 2;

  var clock = new THREE.Clock();

  var solMarker = new DynamicMarker(
      new THREE.Vector3(0, 0, 0),
      SOL_MARKER_RADIUS,
      0x0000FF,
      0
  );

  var selector = new DynamicMarker(
      new THREE.Vector3(0, 0, 0),
      MARKER_RADIUS,
      0x00b33c,
      Math.PI / 4
  );

  var lineMaterial = new THREE.LineBasicMaterial({
    color: 0x0000ff,
    depthWrite: false
  });

  var uniforms = {
    time: {type: "f", value: 1.0},
    scale: {type: "f", value: 80}
  };

  var lineSegment;

  var tooltip;
  var tooltipObject;
  var font;

  var mouseX;
  var mouseY;
  var mouseMoved = false;

  var controlMode = '';
  var highlightMode = 'none';

  var renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    logarithmicDepthBuffer: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = true;

  var raycaster = new THREE.Raycaster();
  var mouse = new THREE.Vector2();

  var freeLookControls = new THREE.FreeLookControls(camera, canvas);
  var orbitControls = new THREE.OrbitControls(camera, canvas);
  var tweenControls = new THREE.TweenControls(camera);

  var shaders = new Shaders();

  var light = new THREE.AmbientLight(0x404040);
  scene.add(light);

  scene.add(camera);
  scene.add(intersectCamera);
  scene.add(solMarker.mesh);
  scene.add(selector.mesh);

  var starData;
  var planetData;

  var stars = [];
  var starsByID = {};
  var planetsByStarID = {};
  var visibleStars = [];
  var visibleStarsByName = {};
  var renderRadius = 75;

  $("#jump_to_list").keydown(function (e) {
    if (e.keyCode == 13) {
      e.preventDefault();
      select(visibleStarsByName[this.value]);
    }
  });

  $("#render_radius").click(function (e) {
    renderRadius = $('input[name=render_radius]:checked', '#render_radius').val();
    updateobjectData();
  });

  $('#control_mode').click(function (e) {
    controlMode = $('input[name=control_mode]:checked', '#control_mode').val();
    updateTarget();
  });

  $("#highlight_mode").click(function (e) {
    highlightMode = $('input[name=highlight_mode]:checked', '#highlight_mode').val();
    stars.forEach(function (starMesh) {
      updateHighlight(starMesh);
    });
  });

  $("#info").click(function (e) {
    e.preventDefault();
  });

  var HIGHLIGHT_MAP = new THREE.TextureLoader().load("images/highlight.png");
  var SPRITE_MATERIAL = new THREE.SpriteMaterial({
    map: HIGHLIGHT_MAP,
    depthWrite: false
  });

  function updateTarget(prevStarMesh) {
    var prevControlMode = controlMode;
    controlMode = 'tween';

    var finalZoom = function (approachTime) {
      return function () {
        tweenControls.setZoom(absolutePosition(currentObjectMesh),
            currentObjectMesh.objectData.radius.value.quantity * 10, approachTime,
            function () {
              if (isStar(currentObjectMesh)) {
                currentSystem.populatePlanets();
              }
              if (isStar(prevStarMesh)) {
                prevStarMesh.objectData.nearbyObjectIDs.forEach(function (e) {
                  resetStarScale(starsByID[e]);
                })
              }
              if (!prevControlMode || prevControlMode == 'tween') {
                controlMode = 'orbit';
              } else {
                controlMode = prevControlMode
              }
              orbitControls.orbit(
                  absolutePosition(currentObjectMesh),
                  currentObjectMesh.objectData.radius.value.quantity * 2
              )
            }
        )
      }
    };

    if (isStar(currentObjectMesh)) {
      tweenControls.setZoom(absolutePosition(currentObjectMesh), MARKER_RADIUS, 2, finalZoom(1));
    } else {
      finalZoom(2)();
    }
  }

  function isStar(mesh) {
    return mesh && mesh.objectData.type == "STAR";
  }

  var currentObjectPrimaryId = "";
  var currentObjectMesh;
  var currentSystem;

  var infoWiki = $("#wiki_box");

  infoWiki.click(function (e) {
    window.open(infoWiki.attr('href'), '_blank');
  });

  function reassignLabel(targetMesh) {
    if (!tooltipObject || tooltipObject.objectData.primaryId == targetMesh.objectData.primaryId) {
      return;
    }
    doReassign(targetMesh);
  }

  var labelCache = {};

  function absolutePosition(mesh) {
    scene.updateMatrixWorld();
    var vector = new THREE.Vector3();
    vector.setFromMatrixPosition(mesh.matrixWorld);
    return vector;
  }

  function doReassign(targetMesh) {
    tooltipObject = targetMesh;

    scene.remove(lineSegment);
    if (tooltip) {
      scene.remove(tooltip.object);
    }

    var targetPos = absolutePosition(targetMesh);
    var geometry = new THREE.Geometry();
    var currentObjPosition = absolutePosition(currentObjectMesh);

    geometry.vertices.push(currentObjPosition);
    geometry.vertices.push(targetPos);
    lineSegment = new THREE.Line(geometry, lineMaterial);

    var lineDistance = currentObjectMesh ? currentObjectMesh.position.distanceTo(targetPos) : 0;
    var label = targetMesh.objectData.properName || "Unnamed Star";
    var cacheKey = label + lineDistance;

    var radiusQuantity = targetMesh.objectData.radius?.value?.quantity || 0.01;

    if (!labelCache[cacheKey]) {
      labelCache[cacheKey] = new TooltipMarker(label, prettyDistance(lineDistance), radiusQuantity);
    }

    tooltip = labelCache[cacheKey];
    tooltip.object.position.set(targetPos.x, targetPos.y, targetPos.z);

    scene.add(lineSegment);
    scene.add(tooltip.object);

    tooltip.updateTo(camera);
  }

  function isRender(objectData) {
    if (objectData.solDistance.value.quantity < renderRadius) {
      return true;
    }
    return false;
  }

  function updateHighlight(starMesh) {
    const highlight = starMesh.children[0];

    if (highlightMode === 'none' ||
        (currentSystem && starMesh.objectData.primaryId === currentSystem.star.objectData.primaryId)) {
      if (highlight) {
        starMesh.remove(highlight);
      }
    } else if (highlightMode === 'exoplanets' && starMesh.objectData.type === "STAR") {
      if (planetsByStarID[starMesh.objectData.primaryId] && planetsByStarID[starMesh.objectData.primaryId][0]) {
        if (!highlight) {
          starMesh.add(createHighlightSprite());
        }
      } else {
        starMesh.remove(highlight);
      }
    } else if (highlightMode === 'all' || starMesh.objectData.type === "VIRTUAL_STAR") {
      if (!highlight) {
        starMesh.add(createHighlightSprite());
      }
    }
  }

  function updateobjectData() {
    var renderedStars = {};
    visibleStars.forEach(function (e) {
      renderedStars[e.objectData.primaryId] = true;
    });
    visibleStars = [];
    visibleStarsByName = {};

    var nameList = [];

    stars.forEach(function (starMesh) {
      var data = starMesh.objectData;
      var starID = data.primaryId;
      var commonName = data.properName || ("Star " + starID);
      nameList.push(commonName);
      visibleStarsByName[commonName] = starMesh;

      if (isRender(data)) {
        visibleStars.push(starMesh);
        if (!renderedStars[starID]) {
          scene.add(starMesh);
        }
      } else {
        if (renderedStars[starID]) {
          scene.remove(starMesh);
          renderedStars[starID] = null;
        }
      }
    });

    if (currentSystem == null) {
      const defaultStar = starsByID[1] || stars[0];
      if (defaultStar) {
        select(defaultStar);
        const labelStar = starsByID[70667] || stars[1] || defaultStar;
        if (labelStar) reassignLabel(labelStar);
      }
    }
    else if (currentSystem && !renderedStars[currentSystem.star.primaryId]) {
      const fallback = starsByID[1] || stars[0];
      if (fallback) select(fallback);
    }

    $("#jump_to_list").autocomplete({
      source: nameList,
      minLength: 4
    });
  }

  function closestNonPrimaryObject(intersects, currentPrimary, currentStarPrimary) {
    if (intersects.length == 0) return null;

    var firstIntersect = intersects[0].object;
    var firstIntersectId = firstIntersect.objectData.primaryId;

    if (intersects.length == 1 && currentPrimary) {
      if (firstIntersectId == currentStarPrimary) return firstIntersect;
      if (firstIntersectId != currentPrimary) return firstIntersect;
    }

    var lookPoint = camera.position;
    var min = Number.MAX_VALUE;
    var best = null;
    intersects.forEach(function (e) {
      var screenDistance = e.object.position.distanceTo(e.point) / lookPoint.distanceTo(e.point);
      var intersectId = e.object.objectData.primaryId;

      if (screenDistance < min && intersectId != currentPrimary && intersectId != currentStarPrimary) {
        best = e.object;
        min = screenDistance;
      }
    });

    return best;
  }

  function getStarForPoint(x, y) {
    if (x && y) {
      mouse.x = (x / window.innerWidth) * 2 - 1;
      mouse.y = -(y / window.innerHeight) * 2 + 1;

      intersectCamera.position.copy(camera.position);
      intersectCamera.rotation.copy(camera.rotation);

      raycaster.setFromCamera(mouse, intersectCamera);

      if (currentSystem) {
        var last = closestNonPrimaryObject(
          raycaster.intersectObjects(currentSystem.selectable, false),
          currentObjectPrimaryId,
          currentSystem.star.objectData.primaryId
        );
        if (last) return currentSystem.objectsByID[last.objectData.primaryId];
      }

      var allStars = visibleStars.concat(virtualStars);
      var lastStar = closestNonPrimaryObject(
        raycaster.intersectObjects(allStars, false),
        currentObjectPrimaryId,
        null
      );

      if (lastStar) return lastStar;

      if (tooltip) {
        var text = raycaster.intersectObjects(tooltip.scaleObj.children, false);
        if (text.length > 0) return tooltipObject;
      }
    }
    return null;
  }

  function setMouseXY(event) {
    mouseX = event.clientX;
    mouseY = event.clientY;
    mouseMoved = true;
  }

  function consumeMouseMove() {
    if (!mouseMoved) return false;
    mouseMoved = false;
    return true;
  }

  function getMouseoverStar() {
    if (!freeLookControls.dragView && consumeMouseMove()) {
      var object = getStarForPoint(mouseX, mouseY);
      if (object) {
        reassignLabel(object);
        canvas.style.cursor = 'pointer';
      } else {
        canvas.style.cursor = 'auto';
      }
    }
  }

  function onMouseClick(event) {
    const diffX = Math.abs(mouseDownX - event.clientX);
    const diffY = Math.abs(mouseDownY - event.clientY);
    const delta = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));

    if (delta < 5) {
      const clickedStar = getStarForPoint(event.clientX, event.clientY);
      if (clickedStar) select(clickedStar);
    }
  }

  function initializeobjectData() {
    starData.forEach(function (star) {
      var shaderSurround = new THREE.ShaderMaterial({
        vertexShader: shaders.coronaVertexShader,
        fragmentShader: shaders.coronaFragmentShader,
        uniforms: {
          scale: {type: "f", value: 0.0},
          temp: {type: "f", value: (star.temperatureEstimate?.value?.quantity || 5000) / 2}
        },
        transparent: true,
        depthWrite: false,
        polygonOffset: .1,
        usePolygonOffset: true
      });

      var surround = new THREE.Mesh(SURROUND_GEOMETRY, shaderSurround);
      surround.objectData = star;
      resetStarScale(surround);
      updateHighlight(surround);

      surround.position.x = star.cartesianCoordsInLys.x;
      surround.position.y = star.cartesianCoordsInLys.y;
      surround.position.z = star.cartesianCoordsInLys.z;

      starsByID[star.primaryId] = surround;
      stars.push(surround);
      planetsByStarID[star.primaryId] = [];
    });

    planetData.forEach(function (planet) {
      var star = planet.starId;
      if (!planetsByStarID[star]) planetsByStarID[star] = [];
      planetsByStarID[star].push(planet);
    });
  }

  function createHighlightSprite() {
    return new THREE.Sprite(SPRITE_MATERIAL);
  }

  function setOffset(raw, current, offset) {
    if (!raw || !offset || !current) return;
    current.x = raw.x - offset.x;
    current.y = raw.y - offset.y;
    current.z = raw.z - offset.z;
  }

  function currentOffset(position) {
    var pos = new THREE.Vector3();
    pos.add(position);
    if (currentSystem) pos.add(currentSystem.star.objectData.cartesianCoordsInLys);
    return pos;
  }

  function select(mesh) {
    if (!mesh) return;

    var newTarget = mesh.objectData;

    if (isStar(mesh)) {
      var offset = mesh.objectData.cartesianCoordsInLys || { x: 0, y: 0, z: 0 };
      stars.forEach(function (e) {
        if (e.objectData.cartesianCoordsInLys) setOffset(e.objectData.cartesianCoordsInLys, e.position, offset);
      });
      setOffset(currentOffset(camera.position), camera.position, offset);
      setOffset(ZERO, solMarker.mesh.position, offset);
    }

    if (newTarget != null) {
      var newTargetPrimaryId = newTarget.primaryId;

      if (newTargetPrimaryId != currentObjectPrimaryId) {
        $('#info-header').text(newTarget.properName);

        var infoTable = $('#info-table');
        infoTable.empty();

        infoTable
            .append($('<tr></tr>').append($('<td class="overlay-header"></td>').text('Characteristics')))
            .append(row("Radius", getValue(newTarget, 'radius')));

        if (newTarget.type == "STAR") {
          infoTable
              .append(row("Class", newTarget.rawStellarClassification || "Unknown"))
              .append(row("Temperature", getValue(newTarget, 'temperatureEstimate') || "N/A"))
              .append(row("Distance (Sol)", getValue(newTarget, 'solDistance') || "Unknown"))
              .append(row("Right ascension", getValue(newTarget, 'rightAscensionRadians') || "Unknown"))
              .append(row("Declination", getValue(newTarget, 'declinationRadians') || "Unknown"))
              .append(row("Abs Magnitude", getValue(newTarget, 'absoluteMagnitude') || "Unknown"))
              .append(row("", ""))
              .append($('<tr></tr>').append($('<td class="overlay-header"></td>').text('Identifiers')))
              .append(row("Proper Name", newTarget.properName || "Unnamed Star"))
              .append(row("Hipparcos", newTarget.identifiers?.hipparcosId || "Unknown"))
              .append(row("Henry Draper", newTarget.identifiers?.henryDraperId || "Unknown"))
              .append(row("Harvard Revised", newTarget.identifiers?.harvardRevised || "Unknown"))
              .append(row("Gliese", newTarget.identifiers?.glieseId || "Unknown"))
              .append(row("Bayer Flamsteed", bfName(newTarget.identifiers?.bayerFlamsteed) || "Unknown"));
        } else {
          infoTable
              .append(row("Mass", getValue(newTarget, 'massKg') || "Unknown"))
              .append(row("Density", getValue(newTarget, 'densityGcc') || "Unknown"))
              .append(row("Orbital Period", getValue(newTarget, 'orbitalPeriodDays') || "Unknown"))
              .append(row("Semi-Major axis", getValue(newTarget, 'semiMajorAxisLys') || "Unknown"))
              .append(row("Semi-Minor axis", getValue(newTarget, 'semiMinorAxisLys') || "Unknown"))
              .append(row("Inclination", getValue(newTarget, 'inclination') || "Unknown"))
              .append(row("Lon asc node", getValue(newTarget, 'longAscendingNode') || "Unknown"))
              .append(row("Arg periapsis", getValue(newTarget, 'argumentPeriapsis') || "Unknown"));
        }

        var prevTargetMesh = currentObjectMesh;
        updateCurrentTargets(mesh);
        updateTarget(prevTargetMesh);
        doReassign(currentObjectMesh);
      }
    }
  }

  function bfName(bayerFlamsteed) {
    if (bayerFlamsteed) return bayerFlamsteed.prettyName;
    return "";
  }

  function isSol(mesh) {
    return mesh.objectData.primaryId == 1;
  }

  function updateCurrentTargets(mesh) {
    currentObjectMesh = mesh;
    currentObjectPrimaryId = mesh.objectData.primaryId;

    if (mesh.objectData.type == "STAR" || mesh.objectData.type == "VIRTUAL_STAR") {
      if (currentSystem && currentSystem.star.objectData.primaryId == mesh.objectData.primaryId) return;

      var prevSystem = currentSystem;

      currentSystem = new System(
          mesh,
          ZERO,
          planetsByStarID[mesh.objectData.primaryId] || [],
          solMarker.mesh.position
      );

      if (isSol(mesh)) currentSystem.object.rotateY(23.5 * Math.PI / 180);

      if (prevSystem) {
        updateHighlight(prevSystem.star);
        scene.remove(prevSystem.object);
      }

      updateHighlight(currentSystem.star);
      scene.add(currentSystem.object);
    }
  }

  function row(name, value) {
    return $('<tr></tr>')
        .append($('<td></td>').text(name))
        .append($('<td></td>').text(value).addClass('info-element'));
  }

  function getValue(data, element) {
    var elem = data[element];
    if (!elem) return "Unknown";
    if (!elem.source) return elem;
    if (elem.source == "DEFAULT") return "?";
    return formatObjValue(elem);
  }

  function formatObjValue(elem) {
    var objValue = elem.value;
    var quantity = objValue.quantity;

    if (objValue.unit == 'LY') return prettyDistance(quantity);
    if (objValue.unit == 'DAY') return quantity + ' days';
    if (objValue.unit == 'KG') return prettyMass(quantity, elem.measurementQualifier);
    if (objValue.unit == 'DEGREE_GEOM') return prettyDegree(quantity);
    if (objValue.unit == 'RADIAN') return prettyDegree(quantity * 57.2958);
    if (objValue.unit == 'MV') return prettyMagnitude(quantity);
    if (objValue.unit == 'K') return prettyTemperature(quantity);
    if (objValue.unit == 'G_PER_CC') return prettyDensity(quantity);
    if (objValue.unit == 'NONE') return quantity;
  }

  function prettyDensity(gPerCc) {
    return gPerCc.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' g/cc';
  }
  function prettyTemperature(k) {
    return k.toLocaleString('en-US', {maximumSignificantDigits: 3}) + 'K';
  }
  function prettyMagnitude(mv) {
    return mv.toLocaleString('en-US', {maximumSignificantDigits: 3}) + 'Mv';
  }
  function prettyDegree(degrees) {
    return degrees.toLocaleString('en-US', {maximumSignificantDigits: 3}) + '°';
  }
  function prettyMass(mass, qualifier) {
    var str = (mass / 5.9722e24).toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' M⊕';
    if (qualifier == 'Msini') str += " (Msini)";
    return str;
  }
  function prettyDistance(lys) {
    if (lys > .01) return lys.toFixed(2) + ' ly';
    var distKM = lys * 9.461e12;
    var distAU = distKM / 1.496e8;
    if (distAU > .01) return distAU.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' AU';
    return distKM.toLocaleString('en-US', {maximumSignificantDigits: 3}) + ' km';
  }

  function onWindowResize() {
    windowHalfX = window.innerWidth / 2;
    windowHalfY = window.innerHeight / 2;
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    render();
  }

  function animate() {
    render();
    requestAnimationFrame(animate);
  }

  function render() {
    var delta = clock.getDelta();
    uniforms.time.value += 0.003 * delta;

    if (controlMode == 'orbit') orbitControls.update(delta);
    else if (controlMode == 'free') freeLookControls.update(delta);
    else if (controlMode == 'tween') tweenControls.update(delta);

    getMouseoverStar();

    if (tooltip) tooltip.updateTo(camera);

    selector.updateTo(camera, delta);
    solMarker.updateTo(camera, delta);

    if (currentSystem) {
      var currentStar = currentSystem.star;
      if (currentStar) {
        (currentStar.objectData.nearbyObjectIDs || []).forEach(function (e) {
          var nearStar = starsByID[e];
          if (!nearStar) return;
          var distance = camera.position.distanceTo(nearStar.position) * .3;
          var childUniform = nearStar.material.uniforms;
          if (childUniform.scale.value != distance) {
            var scale = Math.min(distance, nearStar.objectData.radius.value.quantity * 3000000);
            setStarScale(nearStar, scale);
          }
        });
      }

      var newDistance = prettyDistance(camera.position.distanceTo(currentObjectMesh.position));
      if (lastDistance != newDistance) {
        lastDistance = newDistance;
        distanceHeader.text(newDistance);
      }
    }

    renderer.render(scene, camera);
  }

  function setStarScale(star, scale) {
    star.material.uniforms.scale.value = scale;
    star.scale.x = star.scale.y = star.scale.z = scale;
  }

  function resetStarScale(star) {
    star.material.uniforms.scale.value = star.objectData.radius.value.quantity * 3000000;
    var scale = 7.35355e-8 * 8000000;
    star.scale.set(scale, scale, scale);
  }

  canvas.addEventListener('contextmenu', function (event) { event.preventDefault(); }, false);

  canvas.addEventListener('mousemove', bind(orbitControls.onMouseMove, freeLookControls.onMouseMove), false);
  canvas.addEventListener('mousedown', bind(orbitControls.onMouseDown, freeLookControls.onMouseDown), false);
  canvas.addEventListener('mousewheel', bind(orbitControls.onMouseWheel, freeLookControls.onMouseWheel), false);
  canvas.addEventListener('DOMMouseScroll', bind(orbitControls.onMouseWheel, freeLookControls.onMouseWheel), false);
  canvas.addEventListener('mouseup', bind(orbitControls.onMouseUp, freeLookControls.onMouseUp), false);
  canvas.addEventListener('keydown', bind(orbitControls.onKeyDown, freeLookControls.onKeyDown), false);
  canvas.addEventListener('keyup', bind(orbitControls.onKeyUp, freeLookControls.onKeyUp), false);

  function bind(orbitFn, freeFn) {
    return function () {
      if (controlMode === 'free') freeFn.apply(freeLookControls, arguments);
      else if (controlMode === 'orbit') orbitFn.apply(orbitControls, arguments);
    };
  }

  var mouseDownX = 0;
  var mouseDownY = 0;
  function setmouseDown(event) {
    mouseDownX = event.clientX;
    mouseDownY = event.clientY;
  }

  window.addEventListener('resize', onWindowResize, false);
  canvas.addEventListener('mousemove', setMouseXY, false);
  canvas.addEventListener('mousedown', setmouseDown, false);
  canvas.addEventListener('mouseup', onMouseClick, false);

  var loader = new THREE.FontLoader();

  // ========= catalog loading helpers =========
  const catalogStatusEl = document.getElementById("catalogStatus");
  const loadCatalogBtn = document.getElementById("loadCatalogBtn");
  const clearCatalogBtn = document.getElementById("clearCatalogBtn");
  const catalogFileInput = document.getElementById("catalogFileInput");
  const starmapListEl = document.getElementById("starmapList");
  const MAX_LOCALSTORAGE_CHARS = 3.5 * 1024 * 1024;

  // IMPORTANT: use HTTPS to avoid mixed content blocks
  const STARMAP_INDEX_URL = "https://xtdevelopment.net/chat-proxy/starmaps/starmaps.php";

  function getHashCatalogURL() {
    if (!window.location.hash) return null;
    const raw = window.location.hash.substring(1).trim();
    if (!raw) return null;
    const decoded = decodeURIComponent(raw);
    if (/^https?:\/\//i.test(decoded)) return decoded;
    return null;
  }

  function renameSolIfCustom(catalogObj) {
    if (!catalogObj || !Array.isArray(catalogObj.stars)) return catalogObj;
    const rand = Math.floor(Math.random() * 900000) + 100000;
    catalogObj.stars.forEach(s => {
      if (String(s.primaryId) === "1") {
        s.properName = `Virtual Sol Outpost ${rand}`;
      }
    });
    return catalogObj;
  }

  function resetCatalogScene() {
    try { if (tooltip) { scene.remove(tooltip.object); tooltip = null; } } catch(e){}
    try { if (lineSegment) { scene.remove(lineSegment); lineSegment = null; } } catch(e){}
    try { removeVirtualStars(); } catch(e){}

    if (currentSystem) {
      try { scene.remove(currentSystem.object); } catch(e){}
      currentSystem = null;
    }

    stars.forEach(function (s) { try { scene.remove(s); } catch(e){} });

    stars = [];
    starsByID = {};
    planetsByStarID = {};
    visibleStars = [];
    visibleStarsByName = {};
    currentObjectMesh = null;
    currentObjectPrimaryId = "";
  }

  function applyCatalogObject(dataParsed, isCustom) {
    resetCatalogScene();

    if (isCustom) dataParsed = renameSolIfCustom(dataParsed);

    starData = Array.isArray(dataParsed.stars) ? dataParsed.stars : [];
    planetData = Array.isArray(dataParsed.planets) ? dataParsed.planets : [];

    initializeobjectData();
    updateobjectData();

    catalogStatusEl.style.color = "#8f8";
    catalogStatusEl.textContent =
      `Loaded catalog (${starData.length} stars, ${planetData.length} planets).` +
      (isCustom ? " (custom)" : "");
  }

  function validateCatalogObject(obj) {
    if (!obj || typeof obj !== "object") throw new Error("Catalog is not an object.");
    if (!Array.isArray(obj.stars)) throw new Error("Catalog missing stars[] array.");
    if (!obj.planets) obj.planets = [];

    obj.stars.forEach((s, idx) => {
      if (typeof s.primaryId === "undefined") s.primaryId = idx + 1;
      if (!s.type) s.type = "STAR";
      if (!s.properName) s.properName = `Star ${s.primaryId}`;
      if (!s.cartesianCoordsInLys) s.cartesianCoordsInLys = { x: 0, y: 0, z: 0 };
      if (!s.radius) {
        s.radius = { source: "INFERRED", value: { unit: "LY", quantity: 7.5e-8 } };
      }
      if (!s.solDistance) {
        const d = Math.sqrt(
          s.cartesianCoordsInLys.x**2 +
          s.cartesianCoordsInLys.y**2 +
          s.cartesianCoordsInLys.z**2
        );
        s.solDistance = { source: "INFERRED", value: { unit: "LY", quantity: d } };
      }
      if (!s.temperatureEstimate) {
        s.temperatureEstimate = { source: "DEFAULT", value: { unit: "K", quantity: 5000 } };
      }
      if (!s.nearbyObjectIDs) s.nearbyObjectIDs = [];
      if (!s.identifiers) s.identifiers = {};
    });

    return obj;
  }

  function loadCatalogFromURL(url, isCustom) {
    catalogStatusEl.style.color = "#ffb";
    catalogStatusEl.textContent = "Loading catalog from URL...";

    return $.ajax({
      type: 'GET',
      dataType: 'text',
      url: url,
      success: function (data) {
        var dataParsed = validateCatalogObject(JSON.parse(data));
        applyCatalogObject(dataParsed, !!isCustom);

        if (isCustom) {
          const raw = JSON.stringify(dataParsed);
          if (raw.length <= MAX_LOCALSTORAGE_CHARS) {
            try { localStorage.setItem("customStarCatalog", raw); } catch(e){}
          }
        }
      },
      error: function (xhr, status, err) {
        console.warn("Catalog load failed:", err);
        catalogStatusEl.style.color = "#f88";
        catalogStatusEl.textContent = "Catalog URL failed to load.";
      }
    });
  }

  loadCatalogBtn.addEventListener("click", function() {
    catalogFileInput.value = "";
    catalogFileInput.click();
  });

  clearCatalogBtn.addEventListener("click", function() {
    localStorage.removeItem("customStarCatalog");
    if (history && history.replaceState) {
      history.replaceState(null, "", window.location.pathname + window.location.search);
    }

    catalogStatusEl.style.color = "#ffb";
    catalogStatusEl.textContent = "Reloading default server catalog...";

    loadCatalogFromURL("star_catalog.txt", false).then(() => {
      catalogStatusEl.style.color = "#cfcfcf";
      catalogStatusEl.textContent = "Using server catalog.";
    });
  });

  catalogFileInput.addEventListener("change", function(ev) {
    const file = ev.target.files && ev.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function() {
      try {
        const raw = reader.result;
        const parsed = validateCatalogObject(JSON.parse(raw));

        if (raw.length <= MAX_LOCALSTORAGE_CHARS) {
          try { localStorage.setItem("customStarCatalog", JSON.stringify(parsed)); } catch(e){}
        }

        applyCatalogObject(parsed, true);

      } catch(e) {
        console.error(e);
        catalogStatusEl.style.color = "#f88";
        catalogStatusEl.textContent = "Invalid catalog JSON: " + e.message;
      }
    };
    reader.readAsText(file);
  });

  function loadFallbackCatalog() {
    const cached = localStorage.getItem("customStarCatalog");
    if (cached) {
      try {
        const parsed = validateCatalogObject(JSON.parse(cached));
        applyCatalogObject(parsed, true);
        return $.Deferred().resolve().promise();
      } catch(e) {
        localStorage.removeItem("customStarCatalog");
      }
    }
    return loadCatalogFromURL("star_catalog.txt", false);
  }

  function loadInitialCatalogThenStart() {
    const hashURL = getHashCatalogURL();
    if (hashURL) {
      return loadCatalogFromURL(hashURL, true).then(null, function() {
        return loadFallbackCatalog();
      });
    }
    return loadFallbackCatalog();
  }

  // ======= FIXED starmap list fetch: async, timeout, tolerant parsing =======
  function refreshStarmapList() {
    starmapListEl.innerHTML = `<div style="color:#888;">Loading list...</div>`;

    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 5000); // 5s hard stop

    fetch(STARMAP_INDEX_URL, { signal: controller.signal })
      .then(async r => {
        clearTimeout(timeout);
        const text = await r.text();

        // try JSON parse first
        let urls = null;
        try {
          const parsed = JSON.parse(text);
          if (Array.isArray(parsed)) urls = parsed;
          else if (parsed && Array.isArray(parsed.urls)) urls = parsed.urls;
        } catch(e){
          // not JSON, fall through
        }

        // fallback: line-separated list
        if (!urls) {
          urls = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
        }

        starmapListEl.innerHTML = "";
        if (!urls || urls.length === 0) {
          starmapListEl.innerHTML = `<div style="color:#888;">No starmaps found.</div>`;
          return;
        }

        urls.forEach(url => {
          const name = url.split("/").pop();
          const item = document.createElement("div");
          item.className = "starmap-item";
          item.textContent = name;
          item.dataset.url = url;
          item.onclick = () => loadCatalogFromURL(url, true);
          starmapListEl.appendChild(item);
        });
      })
      .catch(err => {
        clearTimeout(timeout);
        console.warn("Failed to load starmap list:", err);
        starmapListEl.innerHTML = `<div style="color:#f88;">Failed to load list.</div>`;
      });
  }
  // ======= end list fetch fix =======

  $.when(
      loadInitialCatalogThenStart(),
      shaders.loaders()
  ).then(function () {
    loader.load('js/font.js', function (response) {
      font = response;
      initializeobjectData();
      animate();
      updateobjectData();

      // IMPORTANT: don't start list fetch until map is alive
      setTimeout(refreshStarmapList, 0);
    });
  });

  // Auto Explore
  let autoExploreMode = false;
  let autoExploreInterval;

  function toggleAutoExplore() {
    autoExploreMode = !autoExploreMode;

    if (autoExploreMode) {
      document.getElementById("autoExploreButton").innerText = "Stop Auto Explore";
      startAutoExplore();
    } else {
      document.getElementById("autoExploreButton").innerText = "Start Auto Explore";
      stopAutoExplore();
    }
  }

  function startAutoExplore() {
    autoExploreInterval = setInterval(() => {
      const randomStar = getRandomVisibleStar();
      if (randomStar) select(randomStar);
    }, getRandomInterval(7000, 13000));
  }

  function stopAutoExplore() {
    clearInterval(autoExploreInterval);
  }

  function getRandomVisibleStar() {
    const allStars = visibleStars.concat(virtualStars);
    return allStars[Math.floor(Math.random() * allStars.length)];
  }

  function getRandomInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  document.getElementById("autoExploreButton").addEventListener("click", toggleAutoExplore);
</script>
</body>
</html>
